import { common } from '../../common';
import { configuration } from '../config';
import { IAbstractUnit } from './units';
import { IWorkingCopy, IDelta } from './transport-interfaces';
import { ByNameReference } from './references';
import { DeltaQueue } from './deltas';
import { IModelApiClient } from './model-api-client';
import { Structure, IStructure } from './structures';
import { IAbstractElement } from './elements';
import { Version } from './version-checks';
/**
 * This interface exposes a single Mendix Model.
 * This interface contains the parts of the {@link Model} that are exposed through the SDK.
 */
export interface IAbstractModel {
    /**
     * Working copy id of the current opened model (read only)
     */
    id: string;
    /**
     * The meta data of the model.
     */
    metadata: IWorkingCopy;
    metaModelVersion: Version;
    /**
     * Ends the connection with the Model API client.
     * Flushes any pending deltas and invokes the callback once complete.
     * (Errors will be handled through the default modelstore error handler.)
     */
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Deletes this model from the server, and the (SDK) client.
     * If you are altering the model before deleting it, make sure to call this method in the callback of {@link closeConnection}.
     *
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Exports this model as MPK.
     * If you are altering the model before running an export make sure to call this method in the callback of {@link closeConnection}.
     */
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): any;
    /**
     * Given an id, fetches a complete unit. The result might be returned from the cache.
     * Use this method if you have just a unit Id, otherwise, unit.fetch() is a simpler alternative.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): any;
    /**
     * Returns all units in the project, including modules, folders etc.
     * To retrieve all 'real' documents (pages, microflows etc.), use allDocuments().
     */
    allUnits(): IAbstractUnit[];
    /**
     * Given a moduleName, returns a module name
     * (For modules, their qualified name equals their name)
     */
    findModuleByQualifiedName(qname: string): any;
    /**
    * Returns an array of all filepaths in the working copy.
     */
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): any;
    /**
     * Downloads the file specified by the supplied filepath.
     */
    getFile(filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Uploads the supplied file to the specified filepath.
     */
    putFile(inFilePath: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
    /**
     * Deletes the file with the specified filepath.
     */
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): any;
}
export interface IUnitsCache {
    [id: string]: IAbstractUnit;
}
export interface IUnitsByTypeCache {
    [type: string]: IAbstractUnit[];
}
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
export declare abstract class AbstractModel implements IAbstractModel {
    _client: IModelApiClient;
    _errorHandler: common.IErrorCallback;
    protected _connectionConfig: configuration.ISdkConfig;
    metadata: IWorkingCopy;
    metaModelVersion: Version;
    /**
     * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
     */
    _unitsCache: IUnitsCache;
    /**
     * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
     * Please extend the type whenever applicable, for convenience of the programmer.
     */
    protected _unitsByType: IUnitsByTypeCache;
    protected _unresolvedReferences: ByNameReference<any>[];
    protected _areUnitInterfacesLoaded: boolean;
    protected _deltaQueue: DeltaQueue;
    constructor(_client: IModelApiClient, _errorHandler: common.IErrorCallback, _connectionConfig: configuration.ISdkConfig);
    closeConnection(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    /**
     * Instantiates a new Model that can communicate with the server for sending and receiving documents.
     * Loading a Model will automatically fetches all unit interfaces for this working copy and invokes the (success) callback,
     * or calls the errorHandler if this fails.
     */
    static create(client: IModelApiClient, workingCopyInfo: configuration.ICreateWorkingCopyParameters, callback: common.ICallback<IWorkingCopy>, errorCallback: common.IErrorCallback): void;
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback, or call the errorHandler if this fails.
     */
    static read<IT extends IAbstractModel, CT extends AbstractModel>(client: IModelApiClient, workingCopyId: string, connectionConfig: configuration.ISdkConfig, instance: CT, callback: (model: IT) => void, errorCallback: common.IErrorCallback): void;
    private static readImpl(instance, workingCopyId, callback);
    id: string;
    protected _unitTypes: string[];
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     */
    protected _unitInterfacesByType<T extends IAbstractUnit>(typeName: string): T[];
    /**
     * Returns a defensive collection of all units in this model.
     */
    allUnits(): IAbstractUnit[];
    _sendDelta(delta: IDelta): void;
    /**
     * Registers the given `unit` in the cache(s).
     */
    _cache(unit: IAbstractUnit): void;
    /**
     * Unregisters the given `unit` from the cache(s).
     */
    _uncache(unit: IAbstractUnit): void;
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    loadUnitById<T extends IAbstractUnit>(id: string, callback: common.ICallback<T>, errorCallback?: common.IErrorCallback): void;
    protected _loadMetaData(workingCopyId: string, callback: () => void, errorCallback: common.IErrorCallback): void;
    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     */
    protected _loadUnitInterfaces(workingCopyId: string, callback: () => void, errorCallback: common.IErrorCallback): void;
    protected _resolveContainer(unit: IAbstractUnit, containerId: string): void;
    /**
     * If a reference is broken, it should be registered here, so that it can be restored once model elements are renamed.
     */
    _registerUnresolvedReference(ref: ByNameReference<any>): void;
    /**
     * If a reference is no longer broken, it should be unregistered here.
     */
    _unregisterUnresolvedReference(ref: ByNameReference<any>): void;
    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     */
    _processNameChange(element: Structure): void;
    protected _assertConnectionClosed(): void;
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    deleteWorkingCopy(callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    exportMpk(outFilePath: string, callback: common.IVoidCallback, errorCallback?: common.IErrorCallback): void;
    getFilePaths(callback: common.ICallback<string[]>, errorCallback: common.IErrorCallback): void;
    getFile(filePath: string, outFilePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    putFile(inFilePath: string, filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    deleteFile(filePath: string, callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.typeName, "Expenses.Expense.Price");`
     */
    _resolveName(typeName: string, qualifiedName: string): IAbstractElement;
    /**
     * Resolver methods for references by name
     */
    protected _resolveElement(qname: string, docResolver: (qname: string) => IStructure, ...subResolvers: ISubResolver[]): any;
    /**
     * Finds an item in a colleciton
     */
    protected _resolveInCollection<T extends IAbstractUnit>(collection: () => T[], qname: string): T;
    protected _parseQname(qname: string, expectedNumberOfParts: number, target?: string): string[];
    protected _warnAboutUnsupportedType(propertyName: string, qname: string): void;
    findModuleByQualifiedName(qname: string): void;
    _allModelClasses(): void;
}
export interface ISubResolver {
    (parent: IStructure, partName: string): IStructure;
}
