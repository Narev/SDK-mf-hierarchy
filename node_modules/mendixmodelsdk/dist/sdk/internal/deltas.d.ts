import * as transport from './transport-interfaces';
import { common } from '../../common';
import { AbstractModel } from './abstract-model';
/**
 * The `deltas` module does not contain the interfaces for all deltas,
 * but it does contain (all) objects required for building and handling these.
 */
export declare class DeltaTypes {
    static CREATE_ELEMENT: string;
    static UPDATE_PROPERTY_VALUE: string;
    static MOVE_ELEMENT: string;
    static DELETE_ELEMENT: string;
    static CREATE_UNIT: string;
}
export declare class MutatorTypes {
    static CHANGE: string;
    static ADD: string;
    static REMOVE: string;
    static MOVE: string;
}
/**
* A POTSO that wraps a delta and success/failure callbacks.
*/
export declare class DeltaRequest {
    delta: transport.IDelta;
    onSuccess: common.IVoidCallback;
    onFailure: common.IErrorCallback;
    constructor(delta: transport.IDelta, onSuccess?: common.IVoidCallback, onFailure?: common.IErrorCallback);
}
/**
    * A simple queue implementation for deltas.
    */
export declare class DeltaQueue {
    private model;
    private logToConsole;
    private delay;
    private maxDeltasPerBatch;
    private queue;
    private pending;
    isClosing: boolean;
    private closeCallback;
    constructor(model: AbstractModel, logToConsole?: boolean);
    /**
        * Closes the "connection" with the Model API Server in the sense that
        * pending delta requests are processed, and that afterwards the given
        * `callback` will be called.
        * This function can only be called once.
        */
    closeConnection(callback: common.IVoidCallback, errorCallback: common.IErrorCallback): void;
    /**
        * Pushes the given `delta` on the queue for scheduling/processing.
        */
    push(delta: DeltaRequest): void;
    /**
        * Schedules the next delta for processing using JS's event queue/loop.
        */
    private schedule();
    private processNext();
}
