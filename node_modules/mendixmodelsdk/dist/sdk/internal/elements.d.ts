import * as structures from './structures';
import { AbstractModel } from './abstract-model';
/**
 * The `elements` module contains various classes and functions
 * related to elements, specifically: (abstract) elements.
 */
/**
 * Abstract elements are structures that are referable by name.
 * Sub types: (I)Element and (I)ModelUnit.
 */
export interface IAbstractElement extends structures.IStructure {
    isLoaded: boolean;
    qualifiedName: string;
    container: structures.aliases.IContainer;
    _addBackReference(ref: references.AbstractReference<any>): any;
    _removeBackReference(ref: references.AbstractReference<any>): any;
    load<T extends IAbstractElement>(callback?: (elem: T) => void): any;
    load<T extends IAbstractElement>(): T;
}
/**
 * See {@link IAbstractElement}.
 */
export declare class AbstractElement extends structures.Structure implements IAbstractElement {
    container: structures.aliases.Container;
    private _backReferences;
    constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, container: structures.aliases.IContainer);
    /**
     * Checks whether all properties are available at the moment
     *  - if false, a load is required to access these properties.
     */
    isLoaded: boolean;
    /**
     * Calculates the fully qualified name of this element,
     * by visiting all parents that have $isNamespace set to `true`.
     */
    qualifiedName: string;
    /**
     * Transforms a IElement interface into a Element class, loading the containing unit if necessary.
     * (Those are technically already the same, but this function makes sure its properties are available.)
     *
     * - If invoked without callback, it checks whether the properties are available or it will throw;
     * - If invoked with callback, it will load the data from the server if needed, and then invoke the callback.
     */
    load<T extends AbstractElement>(callback?: (elem: T) => void): any;
    load<T extends AbstractElement>(): T;
    /**
     * updateElementsContainer recursively sets the unit to which this elements belong
     * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
     * an element is actually added to the tree (buy pushing / assigning it to some part property)
     */
    protected _updateElementsContainer(unit: units.ModelUnit): void;
    /**
     * Adds a back reference, i.e. a reference pointing to us,
     * which needs to be informed of changes to this element (including deletion).
     */
    _addBackReference(ref: references.AbstractReference<any>): void;
    /**
     * Removes the given back reference.
     */
    _removeBackReference(ref: references.AbstractReference<any>): void;
    delete(): void;
}
/**
 * An element (short for: "model element") lives inside a unit
 * and contains (per being an IStructure) property values.
 */
export interface IElement extends IAbstractElement {
}
export declare type IElementConstructor = typeof Element;
export declare class Element extends AbstractElement implements IElement {
    container: AbstractElement;
    protected _unit: units.ModelUnit;
    constructor(model: AbstractModel, typeName: string, id: string, isPartial: boolean, unit: units.ModelUnit, container: AbstractElement);
    unit: units.ModelUnit;
    /**
     * Checks whether all attributes are available ATM
     *  -  if false, a load is required to access these properties.
     */
    isLoaded: boolean;
    _updateElementsContainer(unit: units.ModelUnit): void;
    /**
     * Sends the appropriate create delta to the server, and also sends all pending deltas,
     * after this element has been assigned to some parent.
     */
    _sendCreateDelta(owner: AbstractElement, parentPropertyName: string): void;
    /**
     * Sends the appropriate create delta to the server
     * after this element has been moved to a new parent.
     */
    _sendMoveDelta(newParent: AbstractElement, newPropertyName: string, index?: number): void;
}
import * as references from './references';
import * as units from './units';
