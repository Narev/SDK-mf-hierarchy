import * as structures from './structures';
import * as elements from './elements';
import * as units from './units';
import * as instances from './instances';
import * as references from './references';
import * as versions from './version-checks';
import { IArrayChange, IArraySplice, IObservableValue, IObservableArray } from 'mobservable';
export { IArrayChange, IArraySplice, IObservableValue, IObservableArray } from 'mobservable';
/**
 * The `properties` sub module contains all interfaces and classes
 * required for handling and wrapping property values/settings.
 */
/**
 * Standard interface for an observable object.
 */
export interface IObservable {
    observe(listener: any, fire: any): () => void;
}
/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
export declare class AbstractProperty<T, P extends IObservable> {
    declaredOn: any;
    parent: structures.Structure;
    name: string;
    handle: () => void;
    observableValue: P;
    /**
     * initialValue is default value except parts and GUID-typed primitives.
     * (by-id/name references do not have default values.)
     */
    constructor(declaredOn: any, parent: structures.Structure, name: string, initialValue: T, ...moreArgs: any[]);
    versionInfo: versions.PropertyVersionInfo;
    isPublic: boolean;
    isRequired: boolean;
    /**
     * Initialize should return something that is observable.
     * The property will observe this internal structure
     * and make sure changes are pushed to the server whenever needed, in its onChange event.
     */
    initialize(value: T, ...moreConstructorArgs: any[]): P;
    fireOnChange(): void;
    onChange(...args: any[]): void;
    get(): T;
    set(newValue: T): void;
    updateWithRawValue(value: any): void;
    assertWritable(): void;
    assertReadable(): void;
    assertPropertyAvailableInCurrentVersion(): void;
    resolveReferences(): void;
    dispose(): void;
    _toPlainJson(): any;
}
/**
 * All primitive types.
 * Note: must match exactly with MxPrimitiveTypeEnum!
 */
export declare enum PrimitiveTypeEnum {
    Integer = 0,
    String = 1,
    Boolean = 2,
    Double = 3,
    DateTime = 4,
    Guid = 5,
    Point = 6,
    Size = 7,
    Color = 8,
    Blob = 9,
}
export declare class PrimitiveProperty<T> extends AbstractProperty<T, IObservableValue<T>> {
    private defaultValue;
    private primitiveType;
    initialize(defaultValue: T, primitiveType: PrimitiveTypeEnum): IObservableValue<T>;
    get(): T;
    set(newValue: T): void;
    updateWithRawValue(value: T): void;
    onChange(newValue: T, oldValue: T): void;
    markCurrentValueAsDefault(): void;
    _toPlainJson(): any;
}
/**
 * Primitive-typed property values list.
 */
export declare class PrimitiveListProperty<T> extends AbstractProperty<T[], IObservableArray<T>> {
    initialize(initialItems: T[]): IObservableArray<T>;
    get(): IObservableArray<T>;
    set(newValue: T[]): void;
    updateWithRawValue(value: T[]): void;
    onChange(change: IArraySplice<T> | IArrayChange<T>): void;
    toRawChangeValue(value: T): any;
    _toPlainJson(): any[];
}
/**
 * A property value that is an enum literal.
 */
export declare class EnumProperty<T extends instances.IEnum> extends PrimitiveProperty<T> {
    private initialValue;
    protected enumType: new (key: string, lifeCycle: versions.ILifeCycle) => instances.IEnum;
    constructor(declaredOn: any, parent: structures.Structure, name: string, initialValue: T, enumType: new (key: string, lifeCycle: versions.ILifeCycle) => instances.IEnum);
    updateWithRawValue(value: any): void;
    set(value: T): void;
    onChange(newValue: any, oldValue: any): void;
    _toPlainJson(): string;
}
/**
 * A property value that is a list of enum literals.
 */
export declare class EnumListProperty<T extends instances.IEnum> extends PrimitiveListProperty<T> {
    private initialValue;
    protected enumType: new (key: string, lifeCycle: versions.ILifeCycle) => instances.IEnum;
    constructor(declaredOn: any, parent: structures.Structure, name: string, initialValue: T[], enumType: new (key: string, lifeCycle: versions.ILifeCycle) => instances.IEnum);
    updateWithRawValue(value: any): void;
    toRawChangeValue(value: T): any;
    _toPlainJson(): string[];
}
/**
 * A property value that is a (model) element.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
export declare class PartProperty<T extends elements.Element> extends AbstractProperty<T, IObservableValue<T>> {
    parent: elements.AbstractElement;
    private hasDefaultValue;
    initialize(value: T, hasDefaultValue: boolean): IObservableValue<T>;
    get(): T;
    set(newValue: T): void;
    updateWithRawValue(value: any): void;
    onChange(newValue: elements.Element, oldValue: elements.Element): void;
    resolveReferences(): void;
    updateElementContainer(unit: units.ModelUnit): void;
    dispose(): void;
    _toPlainJson(): Object;
}
/**
 * A property value that is a list of (model) elements.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
export declare class PartListProperty<T extends elements.Element> extends AbstractProperty<T[], IObservableArray<T>> {
    parent: elements.AbstractElement;
    initialize(initialItems: T[]): IObservableArray<T>;
    get(): IObservableArray<T>;
    set(newValue: T[]): void;
    updateWithRawValue(value: any): void;
    onChange(changeData: IArrayChange<T> | IArraySplice<T>): void;
    processChildRemoval(element: T): void;
    processChildAddition(index: number): void;
    resolveReferences(): void;
    updateElementContainer(unit: units.ModelUnit): void;
    removeChild(child: T): boolean;
    dispose(): void;
    _toPlainJson(): Object[];
}
/**
 * Property value that references a (model) element by name.
 */
export declare class ByNameReferenceProperty<T extends elements.IAbstractElement> extends AbstractProperty<T, references.ByNameReference<T>> {
    private _targetType;
    parent: elements.AbstractElement;
    constructor(declaredOn: any, parent: elements.AbstractElement, name: string, initialValue: T, _targetType: string);
    initialize(value: T, _targetType: string): references.ByNameReference<T>;
    get(): T;
    set(newValue: T): void;
    updateWithRawValue(value: string): void;
    resolveReferences(): void;
    onChange(newValue: T, oldValue: T): void;
    qualifiedName(): string;
    targetType: string;
    dispose(): void;
    _toPlainJson(): string;
}
/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
export declare class ByNameReferenceListProperty<T extends elements.IAbstractElement> extends AbstractProperty<T[], IObservableArray<references.ByNameReference<T>>> {
    private _targetType;
    parent: elements.AbstractElement;
    private viewList;
    private viewListDisposer;
    constructor(declaredOn: any, parent: elements.AbstractElement, name: string, value: T[], _targetType: string);
    initialize(value: T[]): IObservableArray<references.ByNameReference<T>>;
    get(): instances.IList<T>;
    set(newElements: T[]): void;
    updateWithRawValue(qualifiedNames: string[]): void;
    resolveReferences(): void;
    qualifiedNames(): string[];
    dispose(): void;
    supressViewEvents: boolean;
    replaceViewItems(newItems: T[]): void;
    onChange(changeData: IArrayChange<references.ByNameReference<T>> | IArraySplice<references.ByNameReference<T>>): void;
    toRawChangeValue(reference: references.ByNameReference<T>): any;
    targetType: string;
    _toPlainJson(): string[];
}
/**
 * Property value that references a (model) element by id.
 */
export declare class ByIdReferenceProperty<T extends elements.AbstractElement> extends AbstractProperty<T, references.ByIdReference<T>> {
    parent: elements.AbstractElement;
    initialize(value: T): references.ByIdReference<T>;
    get(): T;
    set(value: T): void;
    updateWithRawValue(value: string): void;
    resolveReferences(): void;
    onChange(newValue: T, oldValue: T): void;
    updateElementContainer(): void;
    dispose(): void;
    _toPlainJson(): string;
}
/**
 * Value of a property owned by a structural unit.
 */
export declare class StructuralChildProperty<T> extends AbstractProperty<T, IObservableValue<T>> {
    constructor(declaredOn: any, parent: units.StructuralUnit, name: string, value: T, targetRefType?: string);
    initialize(value: T): IObservableValue<T>;
    get(): T;
    set(value: T): void;
    updateWithRawValue(value: any): void;
    dispose(): void;
}
/**
 * Property instance that wraps a list of structural units.
 */
export declare class StructuralChildListProperty<T> extends AbstractProperty<T[], IObservableArray<T>> {
    constructor(declaredOn: any, parent: units.StructuralUnit, name: string, value: T[], targetRefType?: string);
    initialize(value: T[]): IObservableArray<T>;
    get(): instances.IList<T>;
    set(value: T[]): void;
    updateWithRawValue(value: any): void;
    dispose(): void;
}
