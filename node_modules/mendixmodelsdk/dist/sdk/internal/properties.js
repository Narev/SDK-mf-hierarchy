var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash = require('lodash');
var instances = require('./instances');
var deltas = require('./deltas');
var references = require('./references');
var mobservable_1 = require('mobservable');
/**
 * Abstract base wrapper for property values/settings.
 * All values/settings of ModelElement-s are wrapped in the appropriate way.
 * This is particularly important for reference values which require additional magic.
 */
var AbstractProperty = (function () {
    function AbstractProperty(declaredOn, parent, name) {
        var initializeArgs = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            initializeArgs[_i - 3] = arguments[_i];
        }
        this.declaredOn = declaredOn;
        this.parent = parent;
        this.name = name;
        parent._registerProperty(this);
        this.observableValue = this.initialize.apply(this, initializeArgs);
        this.handle = this.observableValue.observe(this.fireOnChange.bind(this), false);
    }
    Object.defineProperty(AbstractProperty.prototype, "versionInfo", {
        get: function () {
            return (this.declaredOn['versionInfo']).getPropertyVersionInfo(this.name);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isPublic", {
        get: function () {
            return this.versionInfo.isPublic.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractProperty.prototype, "isRequired", {
        get: function () {
            return this.versionInfo.isRequired.isEnabledIn(this.parent.model.metaModelVersion);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize should return something that is observable.
     * The property will observe this internal structure
     * and make sure changes are pushed to the server whenever needed, in its onChange event.
     */
    AbstractProperty.prototype.initialize = function (value) {
        var moreConstructorArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            moreConstructorArgs[_i - 1] = arguments[_i];
        }
        throw new Error("This function should be overriden in subclass");
    };
    AbstractProperty.prototype.fireOnChange = function () {
        if (!this.parent._isUpdating) {
            this.assertWritable();
            this.onChange.apply(this, arguments);
        }
    };
    AbstractProperty.prototype.onChange = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.get = function () {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.set = function (newValue) {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("This function should be overridden in subclass");
    };
    AbstractProperty.prototype.assertWritable = function () {
        this.parent._assertLoaded(this);
        this.assertPropertyAvailableInCurrentVersion();
    };
    AbstractProperty.prototype.assertReadable = function () {
        if (!this.isPublic) {
            this.parent._assertLoaded(this);
        }
        this.assertPropertyAvailableInCurrentVersion();
    };
    AbstractProperty.prototype.assertPropertyAvailableInCurrentVersion = function () {
        // parent check is done here and not in property info, because the actual type of the structure
        // might have different version annations as the type that declared the property
        this.parent.versionInfo.checkStructureVersion(this.parent, true);
        this.versionInfo.checkPropertyVersion(this, true);
    };
    AbstractProperty.prototype.resolveReferences = function () {
        // empty stub
    };
    AbstractProperty.prototype.dispose = function () {
        this.handle();
    };
    AbstractProperty.prototype._toPlainJson = function () {
        throw new Error("Cannot JSON-serialize property: " + this + " (this function should be overridden in sub class)");
    };
    return AbstractProperty;
})();
exports.AbstractProperty = AbstractProperty;
/**
 * All primitive types.
 * Note: must match exactly with MxPrimitiveTypeEnum!
 */
(function (PrimitiveTypeEnum) {
    PrimitiveTypeEnum[PrimitiveTypeEnum["Integer"] = 0] = "Integer";
    PrimitiveTypeEnum[PrimitiveTypeEnum["String"] = 1] = "String";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Boolean"] = 2] = "Boolean";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Double"] = 3] = "Double";
    PrimitiveTypeEnum[PrimitiveTypeEnum["DateTime"] = 4] = "DateTime";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Guid"] = 5] = "Guid";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Point"] = 6] = "Point";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Size"] = 7] = "Size";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Color"] = 8] = "Color";
    PrimitiveTypeEnum[PrimitiveTypeEnum["Blob"] = 9] = "Blob";
})(exports.PrimitiveTypeEnum || (exports.PrimitiveTypeEnum = {}));
var PrimitiveTypeEnum = exports.PrimitiveTypeEnum;
function isNothing(x) {
    return typeof x === "undefined" || x === null;
}
function assertNotNull(value, propertyName, listy) {
    if (listy === void 0) { listy = false; }
    if (isNothing(value)) {
        throw new Error(listy ? "Cannot push null to " + propertyName : "Cannot set " + propertyName + " to null");
    }
}
/*
 * Primitive-typed property value
 */
var PrimitiveProperty = (function (_super) {
    __extends(PrimitiveProperty, _super);
    function PrimitiveProperty() {
        _super.apply(this, arguments);
    }
    PrimitiveProperty.prototype.initialize = function (defaultValue, primitiveType) {
        this.defaultValue = defaultValue;
        this.primitiveType = primitiveType;
        return mobservable_1.observable(mobservable_1.asReference(defaultValue));
    };
    PrimitiveProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue();
    };
    PrimitiveProperty.prototype.set = function (newValue) {
        assertNotNull(newValue, this.name);
        this.assertWritable();
        this.observableValue(newValue);
    };
    PrimitiveProperty.prototype.updateWithRawValue = function (value) {
        assertNotNull(value, this.name);
        this.observableValue(value);
    };
    PrimitiveProperty.prototype.onChange = function (newValue, oldValue) {
        if (this.name === "name")
            this.parent._processNameChange();
        this.parent._sendChangeDelta(this.name, newValue);
    };
    PrimitiveProperty.prototype.markCurrentValueAsDefault = function () {
        this.defaultValue = this.get();
    };
    PrimitiveProperty.prototype._toPlainJson = function () {
        // skip values which are unlikely to have any human-readable meaning:
        if (this.primitiveType === PrimitiveTypeEnum.Guid || this.primitiveType === PrimitiveTypeEnum.Blob)
            return void 0;
        else
            return this.get();
    };
    return PrimitiveProperty;
})(AbstractProperty);
exports.PrimitiveProperty = PrimitiveProperty;
/**
 * Primitive-typed property values list.
 */
var PrimitiveListProperty = (function (_super) {
    __extends(PrimitiveListProperty, _super);
    function PrimitiveListProperty() {
        _super.apply(this, arguments);
    }
    /*
    * Currently, only possible default value for listy properties is [],
    * so we don't have to store initialItems to be able to distinguish from default value.
    */
    PrimitiveListProperty.prototype.initialize = function (initialItems) {
        return mobservable_1.observable(mobservable_1.asFlat(initialItems || []));
    };
    PrimitiveListProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue;
    };
    PrimitiveListProperty.prototype.set = function (newValue) {
        this.assertWritable();
        this.observableValue.replace(newValue);
    };
    PrimitiveListProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.replace(value);
    };
    PrimitiveListProperty.prototype.onChange = function (change) {
        this.assertWritable();
        switch (change.type) {
            case 'update': {
                var c = change;
                assertNotNull(c.object[c.index], this.name, true);
                this.parent._sendChangeDelta(this.name, this.toRawChangeValue(c.object[c.index]), deltas.MutatorTypes.CHANGE, c.index);
                return;
            }
            case 'splice': {
                var c = change;
                for (var i = c.removed.length; i > 0; i--) {
                    this.parent._sendChangeDelta(this.name, null, deltas.MutatorTypes.REMOVE, c.index + i);
                }
                for (var i = 0; i < c.addedCount; i++) {
                    assertNotNull(c.object[c.index + i], this.name, true);
                    this.parent._sendChangeDelta(this.name, this.toRawChangeValue(c.object[c.index + i]), deltas.MutatorTypes.ADD, c.index + i);
                }
                return;
            }
        }
    };
    PrimitiveListProperty.prototype.toRawChangeValue = function (value) {
        return value; // primitives can be sent verbatim to the server
    };
    PrimitiveListProperty.prototype._toPlainJson = function () {
        return this.get();
    };
    return PrimitiveListProperty;
})(AbstractProperty);
exports.PrimitiveListProperty = PrimitiveListProperty;
/**
 * A property value that is an enum literal.
 */
var EnumProperty = (function (_super) {
    __extends(EnumProperty, _super);
    function EnumProperty(declaredOn, parent, name, initialValue, enumType) {
        _super.call(this, declaredOn, parent, name, initialValue);
        this.initialValue = initialValue;
        this.enumType = enumType;
    }
    EnumProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue(this.enumType[value] || this.initialValue);
    };
    EnumProperty.prototype.set = function (value) {
        if (value)
            value.checkEnumVersion(this.parent.model.metaModelVersion, true);
        _super.prototype.set.call(this, value);
    };
    EnumProperty.prototype.onChange = function (newValue, oldValue) {
        _super.prototype.onChange.call(this, newValue.toString(), oldValue.toString());
    };
    EnumProperty.prototype._toPlainJson = function () {
        return this.get().name;
    };
    return EnumProperty;
})(PrimitiveProperty);
exports.EnumProperty = EnumProperty;
/**
 * A property value that is a list of enum literals.
 */
var EnumListProperty = (function (_super) {
    __extends(EnumListProperty, _super);
    function EnumListProperty(declaredOn, parent, name, initialValue, enumType) {
        _super.call(this, declaredOn, parent, name, initialValue);
        this.initialValue = initialValue;
        this.enumType = enumType;
    }
    EnumListProperty.prototype.updateWithRawValue = function (value) {
        var _this = this;
        this.observableValue.replace(value
            ? value.map(function (e) { return _this.enumType[e] || _this.initialValue; })
            : []);
    };
    EnumListProperty.prototype.toRawChangeValue = function (value) {
        if (value) {
            value.checkEnumVersion(this.parent.model.metaModelVersion, true);
            return value.toString(); // send enum string representation to the server
        }
        return null;
    };
    EnumListProperty.prototype._toPlainJson = function () {
        return this.get().map(function (item) { return item.name; });
    };
    return EnumListProperty;
})(PrimitiveListProperty);
exports.EnumListProperty = EnumListProperty;
/**
 * A property value that is a (model) element.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
var PartProperty = (function (_super) {
    __extends(PartProperty, _super);
    function PartProperty() {
        _super.apply(this, arguments);
    }
    PartProperty.prototype.initialize = function (value, hasDefaultValue) {
        this.hasDefaultValue = hasDefaultValue;
        return mobservable_1.observable(mobservable_1.asReference(value));
    };
    PartProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue();
    };
    PartProperty.prototype.set = function (newValue) {
        if (this.isRequired && !newValue) {
            throw new Error("Cannot unset required part property");
        }
        this.assertWritable();
        if (newValue) {
            newValue.versionInfo.checkSameModelVersion(newValue.model, this.parent.model);
            newValue.versionInfo.checkStructureVersion(newValue, true);
        }
        this.observableValue(newValue);
    };
    PartProperty.prototype.updateWithRawValue = function (value) {
        var newChild = instances.instancehelpers.modelElementJsonToInstance(this.parent._model, this.parent.unit, this.parent, value, this.parent._isPartial);
        // cleanup old value, we got a server side change that this child is no longer ours:
        var currentChild = this.observableValue();
        if (currentChild !== null && currentChild !== newChild)
            currentChild._dispose();
        this.observableValue(newChild);
    };
    PartProperty.prototype.onChange = function (newValue, oldValue) {
        this.assertWritable();
        // if the oldvalue was not moved to another element, delete it:
        if (oldValue && oldValue.container === this.parent) {
            oldValue.container = null;
            if (oldValue._isNew)
                oldValue._dispose();
            else
                oldValue.delete();
        }
        if (newValue) {
            if (newValue._isNew) {
                newValue.container = this.parent;
                if (!this.parent._isNew)
                    newValue._updateElementsContainer(this.parent.unit);
                newValue._sendCreateDelta(this.parent, this.name);
            }
            else
                newValue._sendMoveDelta(this.parent, this.name);
        }
    };
    PartProperty.prototype.resolveReferences = function () {
        if (this.observableValue())
            this.observableValue()._resolveReferences();
    };
    PartProperty.prototype.updateElementContainer = function (unit) {
        if (this.observableValue())
            this.observableValue()._updateElementsContainer(unit);
    };
    PartProperty.prototype.dispose = function () {
        if (this.observableValue())
            this.observableValue()._dispose();
    };
    PartProperty.prototype._toPlainJson = function () {
        var value = this.get();
        return value ? value.toPlainJson() : null;
    };
    return PartProperty;
})(AbstractProperty);
exports.PartProperty = PartProperty;
/**
 * A property value that is a list of (model) elements.
 * Will detect when children are moved, added, deleted and sends the appropriate deltas.
 */
var PartListProperty = (function (_super) {
    __extends(PartListProperty, _super);
    function PartListProperty() {
        _super.apply(this, arguments);
    }
    /*
    * Currently, only possible default value for listy properties is [],
    * so we don't have to store initialItems to be able to distinguish from default value.
    */
    PartListProperty.prototype.initialize = function (initialItems) {
        return mobservable_1.observable(mobservable_1.asFlat(initialItems || []));
    };
    PartListProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue;
    };
    PartListProperty.prototype.set = function (newValue) {
        this.assertWritable();
        this.observableValue.replace(newValue);
    };
    PartListProperty.prototype.updateWithRawValue = function (value) {
        var _this = this;
        var newChildren = value.map(function (e) { return instances.instancehelpers.modelElementJsonToInstance(_this.parent._model, _this.parent.unit, _this.parent, e, _this.parent._isPartial); });
        var oldChildren = this.observableValue;
        // dispose old children:
        for (var i = 0; i < oldChildren.length; i++)
            if (newChildren.indexOf(oldChildren[i]) === -1)
                oldChildren[i]._dispose();
        this.observableValue.replace(newChildren);
    };
    PartListProperty.prototype.onChange = function (changeData) {
        var _this = this;
        this.assertWritable();
        // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        switch (changeData.type) {
            case 'splice': {
                var splice = changeData;
                splice.removed.forEach(function (element) { return _this.processChildRemoval(element); });
                for (var i = splice.index; i < splice.index + splice.addedCount; i++)
                    this.processChildAddition(i);
                return;
            }
            case 'update': {
                var update = changeData;
                this.processChildRemoval(update.oldValue);
                this.processChildAddition(update.index);
                return;
            }
        }
    };
    PartListProperty.prototype.processChildRemoval = function (element) {
        /* If the element was removed and not inserted at another place
        * (either on another parent or in the same parent on another index),
        * remove it:
        */
        if (element.container === this.parent && this.observableValue.indexOf(element) === -1) {
            element.container = null;
            element.delete();
        }
    };
    PartListProperty.prototype.processChildAddition = function (index) {
        var item = this.observableValue[index];
        if (!item)
            throw new Error("Null values cannot be added to property '" + this.name + "' of '" + this.parent.typeName + "#" + this.parent.id + "'");
        item.versionInfo.checkSameModelVersion(item.model, this.parent.model);
        item.versionInfo.checkStructureVersion(item, true);
        if (this.observableValue.filter(function (other) { return other === item; }).length > 1)
            throw new Error("Object '" + item.typeName + "#" + item.id + "' was added more than once to property '" + this.name + "' of '" + this.parent.typeName + "#" + this.parent.id + "'");
        if (item._isNew) {
            item.container = this.parent;
            if (!this.parent._isNew)
                item._updateElementsContainer(this.parent.unit);
            item.unit = this.parent.unit;
            item._sendCreateDelta(this.parent, this.name); // TODO: send move as well, if index is not last
        }
        else
            item._sendMoveDelta(this.parent, this.name, index);
    };
    PartListProperty.prototype.resolveReferences = function () {
        this.observableValue.forEach(function (item) { return item._resolveReferences(); });
    };
    PartListProperty.prototype.updateElementContainer = function (unit) {
        this.observableValue.forEach(function (item) { return item._updateElementsContainer(unit); });
    };
    PartListProperty.prototype.removeChild = function (child) {
        var idx = this.observableValue.indexOf(child);
        if (idx >= 0) {
            this.observableValue.splice(idx, 1);
            return true;
        }
        return false;
    };
    PartListProperty.prototype.dispose = function () {
        this.observableValue.forEach(function (elem) { return elem._dispose(); });
    };
    PartListProperty.prototype._toPlainJson = function () {
        return this.get().map(function (item) { return item.toPlainJson(); });
    };
    return PartListProperty;
})(AbstractProperty);
exports.PartListProperty = PartListProperty;
/**
 * Property value that references a (model) element by name.
 */
var ByNameReferenceProperty = (function (_super) {
    __extends(ByNameReferenceProperty, _super);
    function ByNameReferenceProperty(declaredOn, parent, name, initialValue, _targetType) {
        _super.call(this, declaredOn, parent, name, initialValue, _targetType);
        this._targetType = _targetType;
    }
    ByNameReferenceProperty.prototype.initialize = function (value, _targetType) {
        return new references.ByNameReference(this.parent, _targetType);
    };
    ByNameReferenceProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue.get();
    };
    ByNameReferenceProperty.prototype.set = function (newValue) {
        if (this.isRequired && !newValue) {
            throw new Error("Cannot unset required property");
        }
        this.assertWritable();
        this.observableValue.set(newValue);
    };
    ByNameReferenceProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.updateWithRawValue(value);
    };
    ByNameReferenceProperty.prototype.resolveReferences = function () {
        this.observableValue.resolve();
    };
    ByNameReferenceProperty.prototype.onChange = function (newValue, oldValue) {
        this.parent._sendChangeDelta(this.name, newValue ? newValue.qualifiedName : null);
    };
    ByNameReferenceProperty.prototype.qualifiedName = function () {
        return this.observableValue.qualifiedName();
    };
    Object.defineProperty(ByNameReferenceProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    ByNameReferenceProperty.prototype.dispose = function () {
        this.observableValue.dispose();
        _super.prototype.dispose.call(this);
    };
    ByNameReferenceProperty.prototype._toPlainJson = function () {
        return (this.isRequired || this.get()) ? this.qualifiedName() : null;
    };
    return ByNameReferenceProperty;
})(AbstractProperty);
exports.ByNameReferenceProperty = ByNameReferenceProperty;
/**
 * Property value that references zero or more (model) elements by name.
 *
 * The reference list is only used internally, and externally a view of the reference list that returns the real objects is exposed.
 * So, the flow is either:
 *  [server] -> [internal ref list (observable)] -> [update view]
 * or:
 *  [Sdk] -> [view] -- onchange ---> [internal ref list] --- onChange event ---> [send delta's]
 *
 * For simplicity's sake, referencesByName should be considered immutable here (TODO: they should be in general?),
 * so that their internal value doesn't need to be observed.
 */
var ByNameReferenceListProperty = (function (_super) {
    __extends(ByNameReferenceListProperty, _super);
    function ByNameReferenceListProperty(declaredOn, parent, name, value, _targetType) {
        var _this = this;
        _super.call(this, declaredOn, parent, name, value);
        this._targetType = _targetType;
        this.viewList = mobservable_1.observable(mobservable_1.asFlat([]));
        this.supressViewEvents = false;
        this.viewListDisposer = this.viewList.observe(function (changeData) {
            if (_this.supressViewEvents)
                return;
            // For change data details see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
            switch (changeData.type) {
                case 'splice': {
                    var splice = changeData;
                    var newValues = splice.object.slice(splice.index, splice.index + splice.addedCount);
                    newValues.forEach(function (newValue) { return assertNotNull(newValue, _this.name, true); });
                    var newReferences = newValues.map(function (newValue) {
                        var ref = new references.ByNameReference(_this.parent, _this._targetType);
                        ref.set(newValue);
                        return ref;
                    });
                    (_a = _this.observableValue).splice.apply(_a, [splice.index, splice.removed.length].concat(newReferences)).forEach(function (ref) { return ref.dispose(); });
                    return;
                }
                case 'update': {
                    var update = changeData;
                    if (update.index < 0 || update.index >= _this.observableValue.length)
                        throw new Error("Update index out of bounds " + update.index);
                    var newValue = update.object[update.index];
                    assertNotNull(newValue, _this.name, true);
                    var newRef = new references.ByNameReference(_this.parent, _this._targetType);
                    newRef.set(newValue);
                    _this.observableValue[update.index].dispose();
                    _this.observableValue[update.index] = newRef;
                    return;
                }
            }
            var _a;
        });
    }
    ByNameReferenceListProperty.prototype.initialize = function (value) {
        if (value && value.length > 0)
            throw new Error("Illegal state: can only initialize with []");
        return mobservable_1.observable(mobservable_1.asFlat([]));
    };
    ByNameReferenceListProperty.prototype.get = function () {
        this.assertReadable();
        return this.viewList;
    };
    ByNameReferenceListProperty.prototype.set = function (newElements) {
        throw new Error("Illegal state: cannot re-assign list property - use push or splice instead");
    };
    ByNameReferenceListProperty.prototype.updateWithRawValue = function (qualifiedNames) {
        var _this = this;
        this.replaceViewItems([]);
        this.observableValue.replace((qualifiedNames || []).map(function (qualifiedName) {
            var ref = new references.ByNameReference(_this.parent, _this._targetType);
            ref.updateWithRawValue(qualifiedName);
            return ref;
        }));
    };
    ByNameReferenceListProperty.prototype.resolveReferences = function () {
        this.observableValue.map(function (ref) { return ref.resolve(); });
        this.replaceViewItems(this.observableValue.map(function (ref) { return ref.get(); }));
    };
    ByNameReferenceListProperty.prototype.qualifiedNames = function () {
        return this.observableValue.map(function (ref) { return ref.qualifiedName(); });
    };
    ByNameReferenceListProperty.prototype.dispose = function () {
        this.viewListDisposer(); // prevent further events
        this.observableValue.forEach(function (ref) { return ref.dispose(); });
        _super.prototype.dispose.call(this);
    };
    ByNameReferenceListProperty.prototype.replaceViewItems = function (newItems) {
        this.supressViewEvents = true;
        this.viewList.replace(newItems);
        this.supressViewEvents = false;
    };
    ByNameReferenceListProperty.prototype.onChange = function (changeData) {
        this.assertWritable();
        // Reuse listeness behavior from primitiveList
        // Uses toRawChangeValue to get the raw data
        PrimitiveListProperty.prototype.onChange.apply(this, arguments);
    };
    ByNameReferenceListProperty.prototype.toRawChangeValue = function (reference) {
        return reference.qualifiedName();
    };
    Object.defineProperty(ByNameReferenceListProperty.prototype, "targetType", {
        get: function () {
            return this._targetType;
        },
        enumerable: true,
        configurable: true
    });
    ByNameReferenceListProperty.prototype._toPlainJson = function () {
        return this.qualifiedNames();
    };
    return ByNameReferenceListProperty;
})(AbstractProperty);
exports.ByNameReferenceListProperty = ByNameReferenceListProperty;
/**
 * Property value that references a (model) element by id.
 */
var ByIdReferenceProperty = (function (_super) {
    __extends(ByIdReferenceProperty, _super);
    function ByIdReferenceProperty() {
        _super.apply(this, arguments);
    }
    ByIdReferenceProperty.prototype.initialize = function (value) {
        return new references.ByIdReference(this.parent);
    };
    ByIdReferenceProperty.prototype.get = function () {
        this.assertReadable();
        return this.observableValue.get();
    };
    ByIdReferenceProperty.prototype.set = function (value) {
        this.assertWritable();
        if (!value && this.isRequired) {
            throw new Error("Cannot unset property that is a required by-id reference");
        }
        this.observableValue.set(value);
    };
    ByIdReferenceProperty.prototype.updateWithRawValue = function (value) {
        this.observableValue.updateWithRawValue(value);
    };
    ByIdReferenceProperty.prototype.resolveReferences = function () {
        this.observableValue.resolve();
    };
    ByIdReferenceProperty.prototype.onChange = function (newValue, oldValue) {
        this.assertWritable();
        this.observableValue.assertValueHasSameUnit();
        this.parent._sendChangeDelta(this.name, newValue ? newValue.id : null);
    };
    ByIdReferenceProperty.prototype.updateElementContainer = function () {
        // We didn't know our container before, now we know it, let's check the referred value:
        this.observableValue.assertValueHasSameUnit();
    };
    ByIdReferenceProperty.prototype.dispose = function () {
        this.observableValue.dispose();
        _super.prototype.dispose.call(this);
    };
    ByIdReferenceProperty.prototype._toPlainJson = function () {
        var value = this.get();
        return value ? value.id : null;
    };
    return ByIdReferenceProperty;
})(AbstractProperty);
exports.ByIdReferenceProperty = ByIdReferenceProperty;
// TODO  ByIdReferenceListProperty
/**
 * Value of a property owned by a structural unit.
 */
var StructuralChildProperty = (function (_super) {
    __extends(StructuralChildProperty, _super);
    function StructuralChildProperty(declaredOn, parent, name, value, targetRefType) {
        _super.call(this, declaredOn, parent, name, value);
    }
    StructuralChildProperty.prototype.initialize = function (value) {
        // TODO: throw / ignore?
        return mobservable_1.observable(mobservable_1.asReference(value));
    };
    StructuralChildProperty.prototype.get = function () {
        var _this = this;
        // naive implementation, could be cached in the future
        return lodash.find(this.parent.unit._model._unitsCache, function (unit) { return unit.container === _this.parent && unit._containmentName === _this.name; });
    };
    StructuralChildProperty.prototype.set = function (value) {
        console.warn("Cannot set a property that holds a structural unit");
    };
    StructuralChildProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("Illegal state: cannot update a property that holds a structural unit");
    };
    StructuralChildProperty.prototype.dispose = function () { };
    return StructuralChildProperty;
})(AbstractProperty);
exports.StructuralChildProperty = StructuralChildProperty;
/**
 * Property instance that wraps a list of structural units.
 */
var StructuralChildListProperty = (function (_super) {
    __extends(StructuralChildListProperty, _super);
    function StructuralChildListProperty(declaredOn, parent, name, value, targetRefType) {
        _super.call(this, declaredOn, parent, name, value);
    }
    StructuralChildListProperty.prototype.initialize = function (value) {
        // TODO: throw / ignore?
        return mobservable_1.observable(mobservable_1.asFlat(value || []));
    };
    StructuralChildListProperty.prototype.get = function () {
        var _this = this;
        // naive implementation, could be made smarter in the future
        return lodash.filter(this.parent.unit._model._unitsCache, function (unit) { return unit.container === _this.parent && unit._containmentName === _this.name; });
    };
    StructuralChildListProperty.prototype.set = function (value) {
        console.warn("Cannot set a property that holds structural units");
    };
    StructuralChildListProperty.prototype.updateWithRawValue = function (value) {
        throw new Error("Illegal state: cannot update a property that holds structural units");
    };
    StructuralChildListProperty.prototype.dispose = function () { };
    return StructuralChildListProperty;
})(AbstractProperty);
exports.StructuralChildListProperty = StructuralChildListProperty;
