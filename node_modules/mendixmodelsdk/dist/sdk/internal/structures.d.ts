/**
 * "Something" that contains properties.
 * Concrete sub types: MxElement, MxStructuralUnit, MxModelUnit.
 * Abstract sub types: MxAbstractElement, MxAbstractUnit.
 *
 * Each unit in the model is guaranteed to exist only once in memory.
 */
export interface IStructure {
    id: string;
    typeName: string;
    _declaredAsNamespace: boolean;
    container: aliases.IContainer;
    isLoaded: boolean;
    versionInfo: StructureVersionInfo;
    /**
     * Unit that owns/contains this thing.
     */
    unit: units.IAbstractUnit;
    model: IAbstractModel;
    _resolveReferences(): any;
    _updateWithJson(json: transport.IStructureJson): any;
    /**
     * Renders the structure as plain JSON (without observables magic).
     * This is intended for debugging and development convenience.
     * Note that the resulting object is not of the interface type corresponding to this structure.
     */
    toPlainJson(): Object;
    /**
     * Traverses this structure by calling the provided visitor function
     * on itself and all the structures contained (as part) by it,
     * in depth-first order, and it returns synchronously after that.
     */
    traverse(visit: (structure: IStructure) => void): void;
}
export declare class Structure implements IStructure {
    _model: AbstractModel;
    typeName: string;
    id: string;
    _isPartial: boolean;
    container: aliases.IContainer;
    _declaredAsNamespace: boolean;
    _isUpdating: boolean;
    _isNew: boolean;
    _properties: properties.AbstractProperty<any, any>[];
    /**
     * These deltas where created before the create delta of this element was submitted to the server.
     * As soon as this happens, the queue is processed and should stay empty.
     * Each element is either an delta, or a new child that was added under a specific property.
     */
    _pendingDeltasAfterCreate: (transport.IDelta | [Structure, string])[];
    constructor(_model: AbstractModel, typeName: string, id: string, _isPartial?: boolean, container?: aliases.IContainer);
    _initializeNewInstance(): void;
    _initializeDefaultProperties(): void;
    model: IAbstractModel;
    versionInfo: StructureVersionInfo;
    unit: units.IAbstractUnit;
    isLoaded: boolean;
    /**
     * Asserts that the complete element is available, and not just its public part.
     */
    _assertLoaded(object: Structure | properties.AbstractProperty<any, any>): void;
    _registerProperty(prop: properties.AbstractProperty<any, any>): void;
    /**
     * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
     */
    _resolveReferences(): void;
    /**
     * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
     */
    _processNameChange(): void;
    /**
     * Housekeeping: a child of ours was deleted, so let's find the part that contained it and update that part.
     */
    _removeChild(child: Structure): void;
    /**
     * This model element is no longer part of the model, and can be cleaned up.
     */
    _dispose(): void;
    /**
     * Update an existing (probably partial) interface with real contents received from the server.
     */
    _updateWithJson(json: transport.IStructureJson): void;
    protected _updateWithJsonImpl(json: transport.IStructureJson): void;
    _sendCreateDelta(owner: aliases.Container, parentPropertyName: string): void;
    protected _scheduleDeltaAfterCreate(delta: transport.IDelta): void;
    /**
     * Sends the change delta in case a simple property has changed.
     */
    _sendChangeDelta(propertyName: string, newValue: any, changeType?: string, index?: number): void;
    /**
     * Sends the delete in case that we were removed from the model.
     */
    protected _sendDeleteDelta(): void;
    _markCurrentValuesAsDefaults(): void;
    /**
     * Deletes a model from the model.
     * This will automatically remove the item from its model parent,
     * and update incoming references and send server changes.
     */
    delete(): void;
    toPlainJson(): Object;
    traverse(visit: (structure: IStructure) => void): void;
}
import * as elements from './elements';
import * as properties from './properties';
import * as units from './units';
import { AbstractModel, IAbstractModel } from './abstract-model';
import * as transport from './transport-interfaces';
import { StructureVersionInfo } from './version-checks';
export declare namespace aliases {
    type IContainer = units.IStructuralUnit | elements.IAbstractElement;
    type Container = units.StructuralUnit | elements.AbstractElement;
}
