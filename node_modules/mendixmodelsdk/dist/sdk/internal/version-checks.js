var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils_1 = require('../utils');
var Version = (function () {
    function Version(major, minor, patch) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        // Empty constructor
    }
    Version.parse = function (info) {
        if (!info)
            return null;
        var _a = info.split(".").map(function (x) { return parseInt(x, 10); }), major = _a[0], minor = _a[1], patch = _a[2];
        return new Version(major, minor, patch);
    };
    /**
     * Returns true if this version is strictly larger than the provided version.
     */
    Version.prototype.isAfter = function (other) {
        return this.major > other.major
            || (this.major === other.major && this.minor > other.minor)
            || (this.major === other.major && this.minor === other.minor && this.patch > other.patch);
    };
    Version.prototype.isAfterOrEqual = function (other) {
        return this.isEqualTo(other) || this.isAfter(other);
    };
    /**
     * Returns true if this version is strictly smaller compared to the provided version.
     */
    Version.prototype.isBefore = function (other) {
        return this.major < other.major
            || (this.major === other.major && this.minor < other.minor)
            || (this.major === other.major && this.minor === other.minor && this.patch < other.patch);
    };
    Version.prototype.isBeforeOrEqual = function (other) {
        return this.isEqualTo(other) || this.isBefore(other);
    };
    Version.prototype.isEqualTo = function (other) {
        return this.major === other.major && this.minor === other.minor && this.patch === other.patch;
    };
    Version.prototype.toString = function () {
        return [this.major, this.minor, this.patch].join(".");
    };
    return Version;
})();
exports.Version = Version;
function determineMetaModelVersion(version) {
    var parts = version.split(".", 3);
    parts.forEach(function (x, i) { return parts[i] = x.replace(/^(\d*).*$/, function (_, nr) { return nr || "0"; }); });
    while (parts.length < 3)
        parts.push("0");
    return Version.parse(parts.join("."));
}
exports.determineMetaModelVersion = determineMetaModelVersion;
(function (LifeCycleState) {
    LifeCycleState[LifeCycleState["UNAVAILABLE"] = 0] = "UNAVAILABLE";
    LifeCycleState[LifeCycleState["AVAILABLE"] = 1] = "AVAILABLE";
    LifeCycleState[LifeCycleState["DEPRECATED"] = 2] = "DEPRECATED";
    LifeCycleState[LifeCycleState["REMOVED"] = 3] = "REMOVED";
})(exports.LifeCycleState || (exports.LifeCycleState = {}));
var LifeCycleState = exports.LifeCycleState;
;
var LifeCycle = (function () {
    function LifeCycle(info) {
        this.deprecationMessage = "";
        this.deletionMessage = "";
        if (info) {
            this.introduced = Version.parse(info.introduced);
            this.deprecated = Version.parse(info.deprecated);
            this.deleted = Version.parse(info.deleted);
            this.deprecationMessage = info.deprecationMessage || "";
            this.deletionMessage = info.deletionMessage || "";
        }
    }
    /**
     * Yields true if this feature is available in the specified version, that is:
     * - it was in base, or added before the specified version
     * - it was not removed yet in the given version
     * - deprecation statues does not influence it results
     */
    LifeCycle.prototype.isAvailableIn = function (version) {
        if (this.isRemovedIn(version))
            return false;
        if (!this.introduced)
            return true;
        if (this.introduced.isBeforeOrEqual(version))
            return true;
        return false;
    };
    /**
     * Yields true only if the feature is available, (added but not yet removed) and deprecated in the specified version.
     */
    LifeCycle.prototype.isDeprecatedIn = function (version) {
        return this.isAvailableIn(version) && this.deprecated != null && this.deprecated.isBeforeOrEqual(version);
    };
    /**
     * Yields true only if this version was actively removed in the given version.
     * Doesn't yield true if the feature was not yet introduced in the given version (see isAvailableIn for that)
     */
    LifeCycle.prototype.isRemovedIn = function (version) {
        return this.deleted != null && this.deleted.isBeforeOrEqual(version);
    };
    LifeCycle.prototype.getCurrentState = function (version) {
        if (this.isRemovedIn(version))
            return LifeCycleState.REMOVED;
        if (!this.isAvailableIn(version))
            return LifeCycleState.UNAVAILABLE;
        if (this.isDeprecatedIn(version))
            return LifeCycleState.DEPRECATED;
        return LifeCycleState.AVAILABLE;
    };
    /**
     * Checks a version based on this lifecycle.
     * Returns true if something is thrown or warned, otherwise false
     */
    LifeCycle.prototype.reportVersionIssues = function (version, aboutWhatMessage, printWarnings) {
        switch (this.getCurrentState(version)) {
            case LifeCycleState.UNAVAILABLE:
                throw new Error(aboutWhatMessage + " is not yet available in Mendix version " + version + ". It was introduced in Mendix version " + this.introduced);
            case LifeCycleState.DEPRECATED:
                if (printWarnings)
                    utils_1.utils.warnOnce(aboutWhatMessage + " is deprecated in Mendix version " + version + " (deprecated since Mendix version " + this.deprecated + ") and should no longer be instantiated: " + this.deprecationMessage);
                return true;
            case LifeCycleState.REMOVED:
                throw new Error(aboutWhatMessage + " can no longer be instantiated in Mendix version " + version + " (removed since Mendix version " + this.deleted + "): " + this.deletionMessage + ".");
            case LifeCycleState.AVAILABLE:
                return false;
            default:
                throw new Error("Illegal state");
        }
    };
    return LifeCycle;
})();
exports.LifeCycle = LifeCycle;
var ModifierValueHistory = (function () {
    /**
     * defaultFallback indiciates whether the absence of a lifecycle yields true or false
     */
    function ModifierValueHistory(lifecycle, defaultFallback) {
        if (lifecycle) {
            this.latestValue = lifecycle.currentValue;
            this.changedIn = lifecycle.changedIn ? lifecycle.changedIn.map(Version.parse) : [];
            for (var i = 0; i < this.changedIn.length - 1; i++) {
                if (!this.changedIn[i + 1].isBefore(this.changedIn[i]))
                    throw new Error("The list of version changes is not ordered correctly: " + JSON.stringify(lifecycle));
            }
        }
        else {
            this.changedIn = [];
            this.latestValue = defaultFallback;
        }
    }
    ModifierValueHistory.prototype.isEnabledIn = function (version) {
        if (this.changedIn.length === 0)
            return this.latestValue;
        var nonRelevant = this.changedIn.filter(function (changedInVersion) { return version.isBefore(changedInVersion); });
        // odd or even number of toggles from now back to the relevant version ?
        return nonRelevant.length % 2 === 0 ? this.latestValue : !this.latestValue;
    };
    return ModifierValueHistory;
})();
exports.ModifierValueHistory = ModifierValueHistory;
(function (StructureType) {
    StructureType[StructureType["StructuralUnit"] = 0] = "StructuralUnit";
    StructureType[StructureType["ModelUnit"] = 1] = "ModelUnit";
    StructureType[StructureType["Element"] = 2] = "Element";
})(exports.StructureType || (exports.StructureType = {}));
var StructureType = exports.StructureType;
;
var VersionInfo = (function () {
    function VersionInfo() {
    }
    VersionInfo.prototype.checkSameModelVersion = function (model, otherModel) {
        if (model !== otherModel) {
            throw new Error("It is not possible to combine values coming from two different models");
        }
    };
    return VersionInfo;
})();
exports.VersionInfo = VersionInfo;
var StructureVersionInfo = (function (_super) {
    __extends(StructureVersionInfo, _super);
    function StructureVersionInfo(info, structureType) {
        _super.call(this);
        this.structureType = structureType;
        this.properties = {};
        this.availability = new LifeCycle(info);
        this.isPublic = structureType === StructureType.Element ? new ModifierValueHistory(info.public, false) : new ModifierValueHistory(null, true);
        this.isExperimental = new ModifierValueHistory(info.experimental, false);
        var propertiesArePublicByDefault = structureType === StructureType.StructuralUnit;
        for (var key in info.properties)
            this.properties[key] = new PropertyVersionInfo(info.properties[key], propertiesArePublicByDefault);
        this.defaultPropertyInfo = new PropertyVersionInfo(null, propertiesArePublicByDefault);
    }
    StructureVersionInfo.prototype.checkStructureVersion = function (instance, includeWarnings) {
        var availability = this.availability;
        var metaModelVersion = instance.model.metaModelVersion;
        var typeName = instance.typeName;
        var hasVersionIssues = availability.reportVersionIssues(metaModelVersion, "Type '" + typeName + "'", includeWarnings);
        if (!hasVersionIssues) {
            if (includeWarnings && this.isExperimental && this.isExperimental.isEnabledIn(metaModelVersion))
                utils_1.utils.warnOnce("Type '" + typeName + "' is experimental in Mendix version " + metaModelVersion + " and should be used with care.");
        }
        // there is no need to check super structures; each structure has its own complete set of annotations in the meta model
    };
    StructureVersionInfo.prototype.getPropertyVersionInfo = function (name) {
        return this.properties[name] ? this.properties[name] : this.defaultPropertyInfo;
    };
    return StructureVersionInfo;
})(VersionInfo);
exports.StructureVersionInfo = StructureVersionInfo;
var PropertyVersionInfo = (function (_super) {
    __extends(PropertyVersionInfo, _super);
    function PropertyVersionInfo(info, publicByDefault) {
        _super.call(this);
        this.availability = new LifeCycle(info);
        this.isPublic = new ModifierValueHistory(info ? info.public : null, publicByDefault);
        this.isRequired = new ModifierValueHistory(info ? info.required : null, false);
    }
    PropertyVersionInfo.prototype.checkPropertyVersion = function (property, includeWarnings) {
        var name = property.name;
        var metaModelVersion = property.parent.model.metaModelVersion;
        var availability = property.parent.versionInfo.getPropertyVersionInfo(name).availability;
        var typeName = property.parent.typeName;
        availability.reportVersionIssues(metaModelVersion, "Property '" + name + "' of type '" + typeName + "'", includeWarnings);
    };
    return PropertyVersionInfo;
})(VersionInfo);
exports.PropertyVersionInfo = PropertyVersionInfo;
