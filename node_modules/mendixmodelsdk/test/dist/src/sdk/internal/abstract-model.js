var mobservable = require('mobservable');
var lodash = require('lodash');
var deltas_1 = require('./deltas');
var instances_1 = require('./instances');
var version_checks_1 = require('./version-checks');
var utils_1 = require('../utils');
/**
 * Abstract: this class should never be instantiated. Implementation of {@link IModel}.
 */
var AbstractModel = (function () {
    function AbstractModel(_client, _errorHandler, _connectionConfig) {
        this._client = _client;
        this._errorHandler = _errorHandler;
        this._connectionConfig = _connectionConfig;
        this.metadata = null;
        /**
         * Map unitId -> unit, containing all units of this model, which could be partial(ly loaded).
         */
        this._unitsCache = {};
        /**
         * Map unitType -> units[], containing all units of this model, per type, but not sorted in any particular order.
         * Please extend the type whenever applicable, for convenience of the programmer.
         */
        this._unitsByType = {};
        this._unresolvedReferences = [];
        this._areUnitInterfacesLoaded = false;
        this._deltaQueue = null;
    }
    AbstractModel.prototype.closeConnection = function (callback, errorCallback) {
        var _this = this;
        setTimeout(function () {
            _this._deltaQueue.closeConnection(callback, errorCallback || _this._errorHandler);
        }, 1);
    };
    /**
     * Instantiates a new Model that can communicate with the server for sending and receiving documents.
     * Loading a Model will automatically fetches all unit interfaces for this working copy and invokes the (success) callback,
     * or calls the errorHandler if this fails.
     */
    AbstractModel.create = function (client, workingCopyInfo, callback, errorCallback) {
        client.createWorkingCopy(workingCopyInfo, callback, errorCallback);
    };
    /**
     * Instantiates a new working copy that can communicate with the server for sending and receiving documents.
     * Reading a working copy will automatically fetch all unit interfaces for this working copy and invoke callback, or call the errorHandler if this fails.
     */
    AbstractModel.read = function (client, workingCopyId, connectionConfig, instance, callback, errorCallback) {
        AbstractModel.readImpl(instance, workingCopyId, callback);
    };
    AbstractModel.readImpl = function (instance, workingCopyId, callback) {
        // TODO  use promises to avoid callback admin mess
        var hasMetaData = false;
        var hasInterfaces = false;
        var hasError = false;
        var guardedCallback = function () {
            if (!hasError && hasMetaData && hasInterfaces)
                callback(instance);
        };
        var guardedErrorCallback = function (err) {
            if (!hasError) {
                hasError = true;
                instance._errorHandler(err);
            }
            // Loading is parallel, if multiple erors occur, we are only interested in the first one..
        };
        instance._loadMetaData(workingCopyId, function () {
            hasMetaData = true;
            guardedCallback();
        }, guardedErrorCallback);
        instance._loadUnitInterfaces(workingCopyId, function () {
            hasInterfaces = true;
            guardedCallback();
        }, guardedErrorCallback);
    };
    Object.defineProperty(AbstractModel.prototype, "id", {
        get: function () {
            return this.metadata.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractModel.prototype, "_unitTypes", {
        get: function () {
            return Object.keys(this._unitsByType);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the non-defensive set of unit interfaces of a certain type. Creates the collection lazily if needed.
     */
    AbstractModel.prototype._unitInterfacesByType = function (typeName) {
        if (!(typeName in this._unitsByType))
            mobservable.extendObservable(this._unitsByType, (_a = {}, _a[typeName] = [], _a));
        return this._unitsByType[typeName];
        var _a;
    };
    /**
     * Returns a defensive collection of all units in this model.
     */
    AbstractModel.prototype.allUnits = function () {
        var result = [];
        for (var key in this._unitsByType) {
            var objects = this._unitsByType[key];
            result.push.apply(result, objects.slice());
        }
        return result;
    };
    AbstractModel.prototype._sendDelta = function (delta) {
        this._deltaQueue.push(new deltas_1.DeltaRequest(delta));
    };
    /**
     * Registers the given `unit` in the cache(s).
     */
    AbstractModel.prototype._cache = function (unit) {
        if (!unit.typeName) {
            throw new Error("Illegal state: unit has no type name specified");
        }
        if (!this._unitsCache[unit.id]) {
            this._unitsCache[unit.id] = unit;
            this._unitInterfacesByType(unit.typeName).push(unit);
        }
    };
    /**
     * Unregisters the given `unit` from the cache(s).
     */
    AbstractModel.prototype._uncache = function (unit) {
        delete this._unitsCache[unit.id];
        var idx = this._unitsByType[unit.typeName].indexOf(unit); // yay for pointer equality
        if (idx >= 0)
            this._unitsByType[unit.typeName].splice(idx, 1);
    };
    /**
     * Fetches a complete unit. The result might be returned from the cache.
     */
    AbstractModel.prototype.loadUnitById = function (id, callback, errorCallback) {
        var _this = this;
        if (id === null) {
            callback(null);
            return;
        }
        var unit = this._unitsCache[id];
        if (!unit) {
            throw new Error("Unknown unit ID: " + id);
        }
        else if (unit._isLoading) {
            unit._registerAfterLoadCallback(callback);
        }
        else if (unit.isLoaded) {
            callback(unit);
        }
        else {
            unit._registerAfterLoadCallback(callback);
            unit._markLoading();
            this._client.loadUnitById(this.metadata.id, id, function (data) {
                unit._updateWithJson(data);
                _this._resolveContainer(unit, data.containerId);
                unit._resolveReferences();
                unit._markLoaded();
            }, errorCallback || this._errorHandler);
        }
    };
    AbstractModel.prototype._loadMetaData = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        this._client.loadWorkingCopyMetaData(workingCopyId, function (data) {
            _this.metadata = data;
            _this.metaModelVersion = version_checks_1.determineMetaModelVersion(data.mprMetaData._ProductVersion);
            _this._deltaQueue = new deltas_1.DeltaQueue(_this);
            callback();
        }, errorCallback);
    };
    /**
     * Loads all unit interfaces and caches them.
     * This function cannot be called twice.
     */
    AbstractModel.prototype._loadUnitInterfaces = function (workingCopyId, callback, errorCallback) {
        var _this = this;
        if (this._areUnitInterfacesLoaded)
            throw new Error("Illegal state: unit interfaces already loaded");
        this._client.loadUnitInterfaces(workingCopyId, function (data) {
            data.forEach(function (unitJson) {
                instances_1.instancehelpers.abstractUnitJsonToInstance(_this, unitJson, true);
            });
            // resolve all parents:
            data.filter(function (unitJson) { return !!unitJson.containerId; }).forEach(function (unitJson) {
                var unit = _this._unitsCache[unitJson.$ID];
                _this._resolveContainer(unit, unitJson.containerId);
            });
            // resolve all references:
            Object.keys(_this._unitsCache).forEach(function (key) { return _this._unitsCache[key]._resolveReferences(); });
            _this._areUnitInterfacesLoaded = true;
            callback();
        }, errorCallback);
    };
    AbstractModel.prototype._resolveContainer = function (unit, containerId) {
        if (!unit)
            return; // can happen as long as the meta model isn't complete.
        var container = this._unitsCache[containerId];
        if (!container)
            throw new Error("Invalid container ID: " + containerId);
        if (container != unit)
            unit.container = container;
    };
    /**
     * If a reference is broken, it should be registered here, so that it can be restored once model elements are renamed.
     */
    AbstractModel.prototype._registerUnresolvedReference = function (ref) {
        if (this._unresolvedReferences.indexOf(ref) === -1)
            this._unresolvedReferences.push(ref);
    };
    /**
     * If a reference is no longer broken, it should be unregistered here.
     */
    AbstractModel.prototype._unregisterUnresolvedReference = function (ref) {
        var idx = this._unresolvedReferences.indexOf(ref);
        if (idx >= 0)
            this._unresolvedReferences.splice(idx, 1);
    };
    /**
     * If a model element changes its name, broken by-name references should be attempted to resolve.
     *
     * In the future this might be made smarter and less expensive, once that becomes an issue.
     */
    AbstractModel.prototype._processNameChange = function (element) {
        for (var i = this._unresolvedReferences.length - 1; i >= 0; i--)
            if (this._unresolvedReferences[i].resolve())
                this._unresolvedReferences.splice(i, 1);
    };
    AbstractModel.prototype._assertConnectionClosed = function () {
        if (!this._deltaQueue.isClosing)
            throw new Error("Connection should be closed first");
    };
    /**
     * Deletes this working copy from the server, and the (SDK) client.
     */
    AbstractModel.prototype.deleteWorkingCopy = function (callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.deleteWorkingCopy(this.id, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.exportMpk = function (outFilePath, callback, errorCallback) {
        this._assertConnectionClosed();
        this._client.exportMpk(this.id, outFilePath, callback, errorCallback || this._errorHandler);
    };
    AbstractModel.prototype.getFilePaths = function (callback, errorCallback) {
        this._client.getFilePaths(this.id, callback, errorCallback);
    };
    AbstractModel.prototype.getFile = function (filePath, outFilePath, callback, errorCallback) {
        this._client.getFile(this.id, filePath, outFilePath, callback, errorCallback);
    };
    AbstractModel.prototype.putFile = function (inFilePath, filePath, callback, errorCallback) {
        this._client.putFile(this.id, inFilePath, filePath, callback, errorCallback);
    };
    AbstractModel.prototype.deleteFile = function (filePath, callback, errorCallback) {
        this._client.deleteFile(this.id, filePath, callback, errorCallback);
    };
    /**
     * Given an object type name and a qualified name, finds the corresponding element (or null if the reference is broken).
     * Will always succeed for unbroken references,
     * since all objects that are referred by name should be part of the public interface of the model.
     *
     * Example usage:
     * 	`modelStore.resolveName(domainmodels.Attribute.typeName, "Expenses.Expense.Price");`
     */
    AbstractModel.prototype._resolveName = function (typeName, qualifiedName) {
        if (!typeName)
            throw new Error("Cannot resolve a name without a type");
        if (!qualifiedName)
            return null;
        var parts = typeName.split("$");
        if (parts.length !== 2)
            throw new Error("Qualified type name does not have correct format: " + typeName);
        var funcName = "find" + parts[1] + "ByQualifiedName";
        if (typeof this[funcName] !== "function") {
            throw new Error("Cannot resolve references of type: " + typeName);
        }
        return this[funcName](qualifiedName);
    };
    /**
     * Resolver methods for references by name
     */
    AbstractModel.prototype._resolveElement = function (qname, docResolver) {
        var subResolvers = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            subResolvers[_i - 2] = arguments[_i];
        }
        if (!qname)
            return null;
        var parts = this._parseQname(qname, subResolvers.length + 2);
        var parent = docResolver(parts[0] + "." + parts[1]);
        var currentPart = 2;
        while (!(parent === null || parent === undefined) && currentPart < parts.length) {
            parent = subResolvers[currentPart - 2](parent, parts[currentPart]);
            currentPart += 1;
        }
        return parent;
    };
    /**
     * Finds an item in a colleciton
     */
    AbstractModel.prototype._resolveInCollection = function (collection, qname) {
        if (!qname)
            return null;
        var parts = this._parseQname(qname, 2, "resolve function " + collection['name']);
        return lodash.find(collection.call(this), function (item) { return item.qualifiedName === qname; });
    };
    // Defensive programming, we want to discover implementation errors ASAP here..
    AbstractModel.prototype._parseQname = function (qname, expectedNumberOfParts, target) {
        var parts = qname.split('.');
        if (parts.length !== expectedNumberOfParts) {
            throw new Error("Invalid identifier '" + qname + "'" + (target ? " for " + target : "") + ": expected exactly " + expectedNumberOfParts + " parts.");
        }
        return parts;
    };
    AbstractModel.prototype._warnAboutUnsupportedType = function (propertyName, qname) {
        utils_1.utils.warnOnce("Cannot resolve identifier; the type of the identifiers used by property '" + propertyName + "' is currently not supported. Please use the property '." + propertyName + "QualifiedName' instead to read or update this reference.");
    };
    AbstractModel.prototype.findModuleByQualifiedName = function (qname) {
        throw new Error("Abstract! Should be overriden");
    };
    AbstractModel.prototype._allModelClasses = function () {
        throw new Error("Abstract! Should be overriden");
    };
    return AbstractModel;
})();
exports.AbstractModel = AbstractModel;
