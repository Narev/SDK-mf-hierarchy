/**
 * The `deltas` module does not contain the interfaces for all deltas,
 * but it does contain (all) objects required for building and handling these.
 */
/* Too bad, literal copy of model-api/src/deltas/deltas.ts... */
// class; results in better typedocs.
var DeltaTypes = (function () {
    function DeltaTypes() {
    }
    DeltaTypes.CREATE_ELEMENT = "CREATE_ELEMENT";
    DeltaTypes.UPDATE_PROPERTY_VALUE = "UPDATE_PROPERTY_VALUE";
    DeltaTypes.MOVE_ELEMENT = "MOVE_ELEMENT";
    DeltaTypes.DELETE_ELEMENT = "DELETE_ELEMENT";
    DeltaTypes.CREATE_UNIT = "CREATE_UNIT";
    return DeltaTypes;
})();
exports.DeltaTypes = DeltaTypes;
;
var MutatorTypes = (function () {
    function MutatorTypes() {
    }
    MutatorTypes.CHANGE = "CHANGE";
    MutatorTypes.ADD = "ADD";
    MutatorTypes.REMOVE = "REMOVE";
    MutatorTypes.MOVE = "MOVE";
    return MutatorTypes;
})();
exports.MutatorTypes = MutatorTypes;
;
/**
* A POTSO that wraps a delta and success/failure callbacks.
*/
var DeltaRequest = (function () {
    function DeltaRequest(delta, onSuccess, onFailure) {
        this.delta = delta;
        this.onSuccess = onSuccess;
        this.onFailure = onFailure;
    }
    return DeltaRequest;
})();
exports.DeltaRequest = DeltaRequest;
/**
    * A simple queue implementation for deltas.
    */
var DeltaQueue = (function () {
    function DeltaQueue(model, logToConsole) {
        this.model = model;
        this.logToConsole = logToConsole;
        this.delay = 200; // ms
        this.maxDeltasPerBatch = 1000;
        this.queue = [];
        this.pending = false;
        this.isClosing = false;
    }
    /**
        * Closes the "connection" with the Model API Server in the sense that
        * pending delta requests are processed, and that afterwards the given
        * `callback` will be called.
        * This function can only be called once.
        */
    DeltaQueue.prototype.closeConnection = function (callback, errorCallback /* Not used yet */) {
        if (this.isClosing)
            throw new Error("closeConnection already called");
        this.isClosing = true;
        if (this.pending)
            this.closeCallback = callback;
        else
            callback();
    };
    /**
        * Pushes the given `delta` on the queue for scheduling/processing.
        */
    DeltaQueue.prototype.push = function (delta) {
        if (this.isClosing)
            throw new Error("Delta rejected, delta queue connection has closed.");
        this.queue.push(delta);
        if (this.logToConsole) {
            console.log("Scheduled delta " + JSON.stringify(delta));
        }
        this.schedule();
    };
    /**
        * Schedules the next delta for processing using JS's event queue/loop.
        */
    DeltaQueue.prototype.schedule = function () {
        var _this = this;
        if (this.pending)
            return;
        this.pending = true;
        setTimeout(function () { return _this.processNext(); }, this.delay);
    };
    DeltaQueue.prototype.processNext = function () {
        var _this = this;
        if (this.queue.length === 0) {
            this.pending = false;
            if (this.isClosing && this.closeCallback)
                this.closeCallback();
            return;
        }
        var deltaRequests = this.queue.slice(0, Math.min(this.queue.length, this.maxDeltasPerBatch));
        var deltas = deltaRequests.map(function (deltaRequest) { return deltaRequest.delta; });
        this.model._client.sendDeltas(this.model.metadata.id, deltas, function (results) {
            var nSuccess = results.successResults.length;
            _this.queue.splice(0, nSuccess);
            deltaRequests.slice(0, nSuccess).forEach(function (deltaRequest) {
                if (deltaRequest.onSuccess)
                    deltaRequest.onSuccess();
            });
            if (results.firstError) {
                var failingDelta = deltaRequests[nSuccess];
                if (failingDelta.onFailure)
                    failingDelta.onFailure(results.firstError);
                else
                    _this.model._errorHandler(results.firstError);
            }
            else {
                _this.processNext();
            }
        }, function (err) {
            deltaRequests.forEach(function (deltaRequest) {
                if (deltaRequest.onFailure)
                    deltaRequest.onFailure(err);
            });
            _this.model._errorHandler(err);
        });
    };
    return DeltaQueue;
})();
exports.DeltaQueue = DeltaQueue;
