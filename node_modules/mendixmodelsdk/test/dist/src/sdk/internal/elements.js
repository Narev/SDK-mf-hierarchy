var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var structures = require('./structures');
/**
 * See {@link IAbstractElement}.
 */
var AbstractElement = (function (_super) {
    __extends(AbstractElement, _super);
    function AbstractElement(model, typeName, id, isPartial, container) {
        _super.call(this, model, typeName, id, isPartial, container);
        /*
         * In-memory by-id or by-name references from other elements to this elements.
         * These are the objects that need to be informed when names changes occur, or if the element is deleted.
         */
        this._backReferences = [];
    }
    Object.defineProperty(AbstractElement.prototype, "isLoaded", {
        /**
         * Checks whether all properties are available at the moment
         *  - if false, a load is required to access these properties.
         */
        get: function () {
            return this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractElement.prototype, "qualifiedName", {
        /**
         * Calculates the fully qualified name of this element,
         * by visiting all parents that have $isNamespace set to `true`.
         */
        get: function () {
            var parts = [];
            var element = this.container;
            while (element) {
                if (element._declaredAsNamespace)
                    parts.unshift(element['name']);
                element = element.container;
            }
            parts.push(this['name']);
            return parts.filter(function (n) { return !!n; }).join(".");
        },
        enumerable: true,
        configurable: true
    });
    AbstractElement.prototype.load = function (callback) {
        var _this = this;
        if (!callback) {
            this._assertLoaded(this);
            return this;
        }
        this.unit._model.loadUnitById(this.unit.id, function () {
            // this element should be loaded now!
            _this._assertLoaded(_this);
            callback(_this);
        });
    };
    /**
     * updateElementsContainer recursively sets the unit to which this elements belong
     * During deserialization this is not needed, but if used in the SDK, we only can set the unit once
     * an element is actually added to the tree (buy pushing / assigning it to some part property)
     */
    AbstractElement.prototype._updateElementsContainer = function (unit) {
        this._properties.forEach(function (property) {
            if (property instanceof properties.PartListProperty)
                property.updateElementContainer(unit);
            else if (property instanceof properties.PartProperty)
                property.updateElementContainer(unit);
            else if (property instanceof properties.ByIdReferenceProperty)
                property.updateElementContainer();
        });
    };
    /**
     * Adds a back reference, i.e. a reference pointing to us,
     * which needs to be informed of changes to this element (including deletion).
     */
    AbstractElement.prototype._addBackReference = function (ref) {
        this._backReferences.push(ref);
    };
    /**
     * Removes the given back reference.
     */
    AbstractElement.prototype._removeBackReference = function (ref) {
        var idx = this._backReferences.indexOf(ref);
        if (idx >= 0)
            this._backReferences.splice(idx, 1);
    };
    AbstractElement.prototype.delete = function () {
        for (var i = this._backReferences.length - 1; i >= 0; i--) {
            var ref = this._backReferences[i];
            if (ref instanceof references.ByIdReference) {
                // by-id references? should apply cascading delete! See story 475769
                ref.owner.delete();
            }
            else if (ref instanceof references.ByNameReference) {
                // references by name should no longer resolve
                ref.unresolve();
            }
        }
        this._backReferences = [];
        // avoid roundtrip delete -> remove from parent -> delete etc, so enforce that an element is removed through its parent:
        if (this.container) {
            this.container._removeChild(this);
        }
        else {
            if (!this._isNew)
                this._sendDeleteDelta();
            _super.prototype.delete.call(this);
        }
    };
    return AbstractElement;
})(structures.Structure);
exports.AbstractElement = AbstractElement;
var Element = (function (_super) {
    __extends(Element, _super);
    function Element(model, typeName, id, isPartial, unit, container) {
        _super.call(this, model, typeName, id, isPartial, container);
        if (unit)
            this._updateElementsContainer(unit);
    }
    Object.defineProperty(Element.prototype, "unit", {
        get: function () {
            return this._unit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "isLoaded", {
        /**
         * Checks whether all attributes are available ATM
         *  -  if false, a load is required to access these properties.
         */
        get: function () {
            return this._isNew || this.unit.isLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Element.prototype._updateElementsContainer = function (unit) {
        this._unit = unit;
        unit._elementsCache[this.id] = this;
        this._model = unit._model;
        _super.prototype._updateElementsContainer.call(this, unit);
    };
    /**
     * Sends the appropriate create delta to the server, and also sends all pending deltas,
     * after this element has been assigned to some parent.
     */
    Element.prototype._sendCreateDelta = function (owner, parentPropertyName) {
        var _this = this;
        // TODO: part of this needs to be pulled up to Structure
        if (this._isUpdating)
            return;
        if (!this._isNew)
            throw new Error("Illegal state: cannot send create delta for pre-existing element");
        this._assertLoaded(this);
        if (owner && owner._isNew) {
            // Parent is not known at the server yet, we need to try again later
            owner._pendingDeltasAfterCreate.push([this, parentPropertyName]);
            return;
        }
        if (owner.unit)
            this._updateElementsContainer(owner.unit);
        this.unit._model._sendDelta({
            parentId: owner.id,
            elementType: this.typeName,
            parentPropertyName: parentPropertyName,
            deltaType: deltas.DeltaTypes.CREATE_ELEMENT,
            unitId: this.unit.id,
            elementId: this.id
        });
        this._isNew = false;
        this._pendingDeltasAfterCreate.forEach(function (pending) {
            if (pending instanceof Array)
                pending[0]._sendCreateDelta(_this, pending[1]);
            else {
                var delta = pending;
                delta.unitId = _this.unit.id;
                _this.unit._model._sendDelta(delta);
            }
        });
    };
    /**
     * Sends the appropriate create delta to the server
     * after this element has been moved to a new parent.
     */
    Element.prototype._sendMoveDelta = function (newParent, newPropertyName, index) {
        if (this._isUpdating)
            return;
        if (this._isNew)
            throw new Error("Illegal state: create delta has not been sent yet");
        this._assertLoaded(this);
        var moveDelta = {
            unitId: this.unit.id,
            elementId: this.id,
            deltaType: deltas.DeltaTypes.MOVE_ELEMENT,
            newParentId: newParent.id,
            newParentPropertyName: newPropertyName
        };
        if (index !== undefined)
            moveDelta.newIndex = index;
        this.unit._model._sendDelta(moveDelta);
    };
    return Element;
})(AbstractElement);
exports.Element = Element;
var references = require('./references');
var deltas = require('./deltas');
var properties = require('./properties');
