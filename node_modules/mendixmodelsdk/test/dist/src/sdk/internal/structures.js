var Structure = (function () {
    function Structure(_model, typeName, id, _isPartial, container) {
        if (_isPartial === void 0) { _isPartial = true; }
        if (container === void 0) { container = null; }
        this._model = _model;
        this.typeName = typeName;
        this.id = id;
        this._isPartial = _isPartial;
        this.container = container;
        this._declaredAsNamespace = false;
        // Indicates that the internal data of this element is being updated, as a result of data received from the server, so no
        // storage events should be send
        this._isUpdating = true;
        // This element was just constructed and not yet known server side
        this._isNew = false;
        this._properties = []; // cache, it is used very often, and doesn't change over time
        /**
         * These deltas where created before the create delta of this element was submitted to the server.
         * As soon as this happens, the queue is processed and should stay empty.
         * Each element is either an delta, or a new child that was added under a specific property.
         */
        this._pendingDeltasAfterCreate = [];
        if (!_model)
            throw new Error("Missing model argument");
        if (!id)
            throw new Error("Missing id");
        if (!typeName)
            throw new Error("Missing id");
        this._isNew = false;
        this._isUpdating = true;
    }
    Structure.prototype._initializeNewInstance = function () {
        this._isNew = true;
        this._isPartial = false;
        this._isUpdating = false;
        this._initializeDefaultProperties();
        this._markCurrentValuesAsDefaults();
    };
    Structure.prototype._initializeDefaultProperties = function () {
        // Empty stub, for new istances of this class, properties are initialized as described in the meta model
    };
    Object.defineProperty(Structure.prototype, "model", {
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "versionInfo", {
        get: function () {
            // assumption: versionInfo is *not* inherited. 
            return this.constructor['versionInfo'];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "unit", {
        get: function () {
            throw new Error("Abstract!");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Structure.prototype, "isLoaded", {
        get: function () {
            throw new Error("Abstract!");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Asserts that the complete element is available, and not just its public part.
     */
    Structure.prototype._assertLoaded = function (object) {
        if (!this.isLoaded) {
            var message;
            if (object instanceof Structure) {
                message = "This operation is not allowed on the object '" + object.typeName + "' with ID '" + object.id + "' because it was not fully loaded. Load the object with the '.load(callback)' command.";
            }
            else if (object instanceof properties.AbstractProperty) {
                message = "This operation is not allowed on the property '" + object.name + "' because its parent object '" + object.parent.typeName + "' with ID '" + object.parent.id + "' was not fully loaded. Load the property's parent object with the '.load(callback)' command.";
            }
            throw new Error(message);
        }
    };
    Structure.prototype._registerProperty = function (prop) {
        this._properties.push(prop);
    };
    /**
     * Should be called after deserialization / remote updates, to make sure all references are bound to their actual value.
     */
    Structure.prototype._resolveReferences = function () {
        this._properties.forEach(function (prop) { return prop.resolveReferences(); });
    };
    /**
     * If the name of a model element changes, this might effect currently broken references-by-name, so let's process those.
     */
    Structure.prototype._processNameChange = function () {
        if (this.unit)
            this.unit._model._processNameChange(this);
        // else: not owned yet => cannot have incoming by-name references that need to be changed => no action required
    };
    /**
     * Housekeeping: a child of ours was deleted, so let's find the part that contained it and update that part.
     */
    Structure.prototype._removeChild = function (child) {
        var props = this._properties;
        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (prop instanceof properties.PartListProperty) {
                if (prop.removeChild(child))
                    return;
            }
            else if (prop instanceof properties.PartProperty && prop.get() === child) {
                prop.set(null);
                return;
            }
        }
    };
    /**
     * This model element is no longer part of the model, and can be cleaned up.
     */
    Structure.prototype._dispose = function () {
        this._properties.forEach(function (prop) { return prop.dispose(); });
        // TODO: clean from element cache if element, clean from global cache if unit, delete this.unit.elementsCache[this.id];
    };
    /**
     * Update an existing (probably partial) interface with real contents received from the server.
     */
    Structure.prototype._updateWithJson = function (json) {
        // Only allow to go from partial to full documents once, of course, later on, a full merge would be required
        this._isPartial = false;
        this._isUpdating = true;
        this._updateWithJsonImpl(json);
        this._isUpdating = false;
    };
    Structure.prototype._updateWithJsonImpl = function (json) {
        for (var key in json)
            if (key !== "$ID" && key !== "$Type" && this["__" + key] instanceof properties.AbstractProperty)
                this["__" + key].updateWithRawValue(json[key]);
    };
    Structure.prototype._sendCreateDelta = function (owner, parentPropertyName) {
        throw new Error("Abstract!");
    };
    Structure.prototype._scheduleDeltaAfterCreate = function (delta) {
        // if the create was not send yet to the server, delay this delta until that is done:
        if (this._isNew)
            this._pendingDeltasAfterCreate.push(delta);
        else {
            delta.unitId = this.unit.id;
            this.unit._model._sendDelta(delta);
        }
    };
    /**
     * Sends the change delta in case a simple property has changed.
     */
    Structure.prototype._sendChangeDelta = function (propertyName, newValue, changeType, index) {
        if (changeType === void 0) { changeType = deltas.MutatorTypes.CHANGE; }
        if (index === void 0) { index = -1; }
        if (this._isUpdating)
            return;
        this._assertLoaded(this);
        var mutator = (function () {
            switch (changeType) {
                case deltas.MutatorTypes.CHANGE: {
                    var changeMutator = {
                        value: newValue,
                        mutatorType: changeType
                    };
                    if (index >= 0)
                        changeMutator.updateIndex = index;
                    return changeMutator;
                }
                case deltas.MutatorTypes.ADD: return {
                    value: newValue,
                    mutatorType: changeType,
                    insertionIndex: index
                };
                case deltas.MutatorTypes.REMOVE: return {
                    removalIndex: index,
                    mutatorType: changeType
                };
                // MWE: Moves are currently not implemented as they cannot not be triggered on JS arrays
                // if we had such a change however, the chance on conflicts would be a tiny bit smaller
                case deltas.MutatorTypes.MOVE: throw new Error("Inside list moves are not yet implemented");
            }
        })();
        this._scheduleDeltaAfterCreate({
            unitId: undefined,
            elementId: this.id,
            deltaType: deltas.DeltaTypes.UPDATE_PROPERTY_VALUE,
            propertyName: propertyName,
            mutator: mutator
        });
    };
    /**
     * Sends the delete in case that we were removed from the model.
     */
    Structure.prototype._sendDeleteDelta = function () {
        if (this._isUpdating || this._isNew)
            return;
        this._assertLoaded(this);
        this.unit._model._sendDelta({
            unitId: this.unit.id,
            elementId: this.id,
            deltaType: deltas.DeltaTypes.DELETE_ELEMENT
        });
    };
    Structure.prototype._markCurrentValuesAsDefaults = function () {
        this._properties.forEach(function (property) {
            if (property instanceof properties.PrimitiveProperty) {
                property.markCurrentValueAsDefault();
            }
        });
    };
    /**
     * Deletes a model from the model.
     * This will automatically remove the item from its model parent,
     * and update incoming references and send server changes.
     */
    Structure.prototype.delete = function () {
        // TODO: to be overriden for structural units
        this._dispose();
    };
    Structure.prototype.toPlainJson = function () {
        var json = {
            $id: this.id,
            $type: this.typeName
        };
        this._properties.forEach(function (property) {
            var propertyJson = property._toPlainJson();
            if (typeof propertyJson !== "undefined") {
                json[property['name']] = propertyJson;
            }
        });
        return json;
    };
    Structure.prototype.traverse = function (visit) {
        this._assertLoaded(this);
        visit(this);
        this._properties.forEach(function (property) {
            if (property instanceof properties.PartProperty) {
                var value = property.get();
                if (value)
                    value.traverse(visit);
            }
            else if (property instanceof properties.PartListProperty) {
                property.get().map(function (value) {
                    if (value)
                        value.traverse(visit);
                });
            }
        });
    };
    return Structure;
})();
exports.Structure = Structure;
/**
 * Late dependencies on others, structures should be defined first for proper inheritance!
 */
var deltas = require('./deltas');
var properties = require('./properties');
