/// <reference path="../test-typings.d.ts"/>
var mendixmodelsdk_1 = require("mendixmodelsdk");
var chai_1 = require('chai');
var stub_model_client_1 = require('../helpers/stub-model-client');
var sdk_client_helper_1 = require('../helpers/sdk-client-helper');
var lodash = require('lodash');
var domainModelUnitId = stub_model_client_1.CompanyExpensesStubClient.domainModelUnitId;
describe('meta model checks', function () {
    it('should load units and domain model', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            chai_1.assert.equal(m.allDomainModels().length, 3);
            var d = m.allDomainModels()[1];
            chai_1.assert.equal(d.moduleName, "Expenses");
            done();
        }, done);
    });
    it('should create texts for validation rules with default values', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            chai_1.assert.equal(m.allDomainModels().length, 3);
            var d = m.allDomainModels()[1];
            chai_1.assert.equal(d.moduleName, "Expenses");
            d.load(function (dm) {
                var e = dm.entities[0];
                mendixmodelsdk_1.domainmodels.ValidationRule.createIn(e);
                var vr = e.validationRules[e.validationRules.length - 1];
                var er = vr.errorMessage;
                chai_1.assert.ok(er);
                chai_1.assert.equal(er.translations.length, 1);
                var tl = vr.errorMessage.translations[0];
                chai_1.assert.equal(tl.languageCode, "en_US");
                chai_1.assert.equal(tl.text, "");
                m.closeConnection(function () {
                    chai_1.assert.deepEqual(m['_client'].deltas, [
                        {
                            "deltaType": "CREATE_ELEMENT",
                            "elementId": vr.id,
                            "elementType": "DomainModels$ValidationRule",
                            "parentId": e.id,
                            "parentPropertyName": "validationRules",
                            "unitId": dm.id
                        },
                        {
                            "deltaType": "CREATE_ELEMENT",
                            "elementId": er.id,
                            "elementType": "Texts$Text",
                            "parentId": vr.id,
                            "parentPropertyName": "errorMessage",
                            "unitId": dm.id
                        },
                        {
                            "deltaType": "CREATE_ELEMENT",
                            "elementId": tl.id,
                            "elementType": "Texts$Translation",
                            "parentId": er.id,
                            "parentPropertyName": "translations",
                            "unitId": dm.id
                        },
                        {
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "elementId": tl.id,
                            "mutator": {
                                "mutatorType": "CHANGE",
                                "value": "en_US"
                            },
                            "propertyName": "languageCode",
                            "unitId": dm.id
                        },
                        {
                            "deltaType": "CREATE_ELEMENT",
                            "elementId": vr.ruleInfo.id,
                            "elementType": "DomainModels$RequiredRuleInfo",
                            "parentId": vr.id,
                            "parentPropertyName": "ruleInfo",
                            "unitId": dm.id
                        },
                    ]);
                    done();
                });
            });
        }, done);
    });
    it('should resolve references by id', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            var d = m.allDomainModels()[1];
            var assoc = d.associations[0];
            chai_1.assert.equal(assoc.name, "Expense_ExpenseType");
            chai_1.assert.equal(assoc.parent.name, "Expense");
            chai_1.assert.equal(assoc.child.name, "ExpenseType");
            done();
        }, done);
    });
    it('should generate correct qualified names for attributes', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            var d = m.allDomainModels()[1];
            var e = d.entities.find(function (e) { return e.name === "Expense"; });
            var attr = e.attributes.find(function (a) { return a.name === "Status"; });
            chai_1.assert.ok(attr);
            chai_1.assert.equal(attr.qualifiedName, "Expenses.Expense.Status");
            done();
        }, done);
    });
    it('should resolve references by name in interfaces', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            var d = m.allDomainModels()[1];
            chai_1.assert.equal(d.qualifiedName, "Expenses");
            var assoc = d.crossAssociations[0];
            chai_1.assert.equal(assoc.name, "Conversion_User");
            chai_1.assert.equal(assoc.parent.name, "Conversion");
            // TODO: only available once system module is available...
            // assert.equal(assoc.child.name, "User");
            var entity = m.findEntityByQualifiedName("Expenses.Expense");
            var attr = lodash.find(entity.attributes, function (a) { return a.name === "Status"; });
            chai_1.assert.ok(attr, "attr was not found");
            chai_1.assert.ok(attr.type.enumeration, "enumeration was not resolved");
            chai_1.assert.equal(attr.type.enumeration.name, "Expense_Status");
            done();
        }, done);
    });
    it('should resolve references by name in units', function (done) {
        this.timeout(0);
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            m.loadUnitById(domainModelUnitId, function (d) {
                var entity = m.findEntityByQualifiedName("Expenses.Expense");
                var attr = lodash.find(entity.attributes, function (a) { return a.name === "Status"; });
                chai_1.assert.ok(attr, "attr was not found");
                chai_1.assert.ok(attr.type.enumeration, "enumeration was not resolved");
                chai_1.assert.equal(attr.type.enumeration.name, "Expense_Status");
                chai_1.assert.equal(m['_client'].deltas.length, 0);
                done();
            });
        }, done);
    });
    it('should handle bynamereferencelists', function (done) {
        this.timeout(0);
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            m.allDomainModels().filter(function (d) { return d.qualifiedName === "Expenses"; })[0].load(function (dm) {
                var unitId = dm.id;
                var module = dm.container;
                chai_1.assert.equal(module.moduleSecurity.moduleRoles.length, 3);
                var managerRole = module.moduleSecurity.moduleRoles.find(function (mr) { return mr.name === "Manager"; });
                chai_1.assert.equal(managerRole.qualifiedName, "Expenses.Manager");
                var employeeRole = module.moduleSecurity.moduleRoles.find(function (mr) { return mr.name === "Employee"; });
                chai_1.assert.equal(employeeRole.qualifiedName, "Expenses.Employee");
                var entity = dm.entities.find(function (e) { return e.name === "ExpenseType"; });
                chai_1.assert.equal(entity.accessRules.length, 2, "invalid amount of access rules");
                var ac = entity.accessRules[1];
                chai_1.assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");
                chai_1.assert.equal(ac.moduleRoles[1].qualifiedName, managerRole.qualifiedName);
                chai_1.assert.equal(ac.moduleRoles[1], managerRole);
                ac.moduleRoles[0] = employeeRole;
                ac.moduleRoles.pop();
                chai_1.assert.equal(ac.moduleRoles.length, 1, "invalid amount of module roles in access rule");
                ac.moduleRoles.unshift(managerRole);
                chai_1.assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");
                chai_1.assert.throw(function () {
                    ac.moduleRoles = [employeeRole];
                }, "Illegal state: cannot re-assign list property - use push or splice instead");
                var elementId = "e2c13b7d-efa3-4f56-a7aa-8441fab9f3f6";
                m.closeConnection(function () {
                    chai_1.assert.deepEqual(m['_client'].deltas, [
                        {
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "elementId": elementId,
                            "mutator": {
                                "mutatorType": "CHANGE",
                                "updateIndex": 0,
                                "value": "Expenses.Employee"
                            },
                            "propertyName": "moduleRoles",
                            "unitId": unitId
                        },
                        {
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "elementId": elementId,
                            "mutator": {
                                "mutatorType": "REMOVE",
                                "removalIndex": 2
                            },
                            "propertyName": "moduleRoles",
                            "unitId": unitId,
                        },
                        {
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "elementId": elementId,
                            "mutator": {
                                "insertionIndex": 0,
                                "mutatorType": "ADD",
                                "value": "Expenses.Manager"
                            },
                            "propertyName": "moduleRoles",
                            "unitId": unitId
                        }
                    ]);
                    done();
                });
            });
        }, done);
    });
    var expectedContainmentExceptionMessage = "Cannot update property of '" + mendixmodelsdk_1.domainmodels.Association.typeName + "', the given object is not yet part of a unit. Please add the object to an unit first";
    it('should fail on references to objects not added to the tree yet', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            m.loadUnitById(domainModelUnitId, function (d) {
                var entity = mendixmodelsdk_1.domainmodels.Entity.create(m);
                var assoc = mendixmodelsdk_1.domainmodels.Association.create(m);
                try {
                    assoc.parent = entity;
                }
                catch (e) {
                    chai_1.assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
                    return void done();
                }
                return void done(new Error("expected exception"));
            });
        }, done);
    });
    it('should handle by name reference lists', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (m) {
            m.loadUnitById(domainModelUnitId, function (d) {
                var entity = mendixmodelsdk_1.domainmodels.Entity.create(m);
                var assoc = mendixmodelsdk_1.domainmodels.Association.create(m);
                try {
                    assoc.parent = entity;
                }
                catch (e) {
                    chai_1.assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
                    return void done();
                }
                return void done(new Error("expected exception"));
            });
        }, done);
    });
    it('should pick up renames and deletes of elements that are refered by name', function (done) {
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (model) {
            model.loadUnitById(domainModelUnitId, function (d) {
                // create a cross association (in the same module, but that's ok for now...):
                var crossAssoc = mendixmodelsdk_1.domainmodels.CrossAssociation.create(model);
                d.crossAssociations.unshift(crossAssoc);
                var tempUserEntity = lodash.find(d.entities, function (ent) { return ent.name === "TempUser"; });
                chai_1.assert.ok(tempUserEntity);
                var amountOfEntities = d.entities.length;
                crossAssoc.parent = d.entities[0];
                crossAssoc.child = tempUserEntity; // This entity has no assocs, so can be deleted easily
                chai_1.assert.equal(crossAssoc.childQualifiedName, "Expenses.TempUser");
                // rename an entity:
                tempUserEntity.name = "Renamed";
                chai_1.assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");
                // delete that entity:
                tempUserEntity.delete();
                chai_1.assert.equal(d.entities.length, amountOfEntities - 1);
                // name should be saved, but reference should not resolve anymore:
                chai_1.assert.equal(crossAssoc.__child.observableValue.referenceId, "Expenses.Renamed");
                chai_1.assert.equal(crossAssoc.child, null);
                chai_1.assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");
                // Create new entity, reference should be picked up automatically
                var newEntity = mendixmodelsdk_1.domainmodels.Entity.createIn(d);
                chai_1.assert.equal(d.entities.length, amountOfEntities);
                newEntity.name = "Renamed";
                chai_1.assert.equal(crossAssoc.__child.observableValue.referenceId, "Expenses.Renamed");
                chai_1.assert.equal(crossAssoc.child, newEntity);
                chai_1.assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");
                model.closeConnection(function () {
                    // verify the deltas created during the process:
                    var deltas = model['_client'].deltas.slice();
                    chai_1.assert.deepEqual(deltas, [
                        {
                            "parentId": domainModelUnitId,
                            "elementType": mendixmodelsdk_1.domainmodels.CrossAssociation.typeName,
                            "parentPropertyName": "crossAssociations",
                            "deltaType": "CREATE_ELEMENT",
                            "unitId": domainModelUnitId,
                            "elementId": crossAssoc.id
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": crossAssoc.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "dataStorageGuid",
                            "mutator": {
                                "value": crossAssoc.dataStorageGuid,
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "parentId": crossAssoc.id,
                            "elementType": mendixmodelsdk_1.domainmodels.AssociationDeleteBehavior.typeName,
                            "parentPropertyName": "deleteBehavior",
                            "deltaType": "CREATE_ELEMENT",
                            "unitId": domainModelUnitId,
                            "elementId": crossAssoc.deleteBehavior.id
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": crossAssoc.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "parent",
                            "mutator": {
                                "value": "48345255-c0be-4304-803b-1e53c658eb93",
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": crossAssoc.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "child",
                            "mutator": {
                                "value": "Expenses.TempUser",
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "name",
                            "mutator": {
                                "value": "Renamed",
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
                            "deltaType": "DELETE_ELEMENT"
                        },
                        {
                            "parentId": domainModelUnitId,
                            "elementType": mendixmodelsdk_1.domainmodels.Entity.typeName,
                            "parentPropertyName": "entities",
                            "deltaType": "CREATE_ELEMENT",
                            "unitId": domainModelUnitId,
                            "elementId": newEntity.id
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": newEntity.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "dataStorageGuid",
                            "mutator": {
                                "value": newEntity.dataStorageGuid,
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "unitId": domainModelUnitId,
                            "parentId": newEntity.id,
                            "elementType": mendixmodelsdk_1.domainmodels.NoGeneralization.typeName,
                            "parentPropertyName": "generalization",
                            "deltaType": "CREATE_ELEMENT",
                            "elementId": newEntity.generalization.id
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": newEntity.generalization.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "persistable",
                            "mutator": {
                                "value": true,
                                "mutatorType": "CHANGE"
                            }
                        },
                        {
                            "unitId": domainModelUnitId,
                            "elementId": newEntity.id,
                            "deltaType": "UPDATE_PROPERTY_VALUE",
                            "propertyName": "name",
                            "mutator": {
                                "value": "Renamed",
                                "mutatorType": "CHANGE"
                            }
                        }
                    ]);
                    done();
                });
            });
        }, done);
    });
    it('setting an optional by-id reference to null should clear it (but not remove the referred element)', function (done) {
        this.timeout(0); // avoid debug session being aborted
        sdk_client_helper_1.createSdkClient().openWorkingCopy("1", function (model) {
            model.loadUnitById(domainModelUnitId, function (d) {
                var entity = d.entities[0];
                var attribute1 = entity.attributes[0];
                var index = mendixmodelsdk_1.domainmodels.Index.createIn(entity);
                var indexedAttribute = mendixmodelsdk_1.domainmodels.IndexedAttribute.createIn(index);
                indexedAttribute.attribute = attribute1;
                chai_1.assert.isNotNull(indexedAttribute.attribute);
                indexedAttribute.attribute = null;
                chai_1.assert.isNull(indexedAttribute.attribute); // also: no exception thrown
                chai_1.assert.ok(entity.attributes[0]);
                chai_1.assert.equal(entity.attributes[0].id, attribute1.id);
                model.closeConnection(function () {
                    // verify the deltas created during the process:
                    var lastDelta = model['_client'].deltas.slice(-1)[0];
                    chai_1.assert.deepEqual(lastDelta, {
                        "unitId": domainModelUnitId,
                        "elementId": indexedAttribute.id,
                        "deltaType": "UPDATE_PROPERTY_VALUE",
                        "propertyName": "attribute",
                        "mutator": {
                            "value": null,
                            "mutatorType": "CHANGE"
                        }
                    });
                    done();
                });
            });
        }, done);
    });
});
