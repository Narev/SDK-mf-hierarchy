import * as internal from '../../src/sdk/internal';
export import StructureVersionInfo = internal.StructureVersionInfo;
import {utils} from '../../src/sdk/utils';
import {common}  from '../../src/common';


export namespace domainmodels_simple {

    export class MyEnum extends internal.IEnum {
        protected qualifiedTsTypeName = "domainmodels_simple.MyEnum";
        public static FirstValue = new MyEnum("FirstValue", {
          "introduced" : "6.0.1",
          "deprecated" : "6.0.4",
          "deprecationMessage" : null,
          "deleted" : "6.1.0",
          "deletionMessage" : null
        });
        public static SecondValue = new MyEnum("SecondValue", { });
        public static AnotherValue = new MyEnum("AnotherValue", { });
    }


    /**
     * Interfaces and instance classes for types from the Mendix sub meta model `DomainModels_simple`.
     */


    /**
     * In version 6.2.0: deleted
     * In version 6.0.4: deprecated
     * In version 6.0.1: introduced
     */
    export interface IAttribute extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():Attribute;
        load(callback:(element:Attribute)=>void);
        name:string;
        /**
         * This property is required and cannot be set to null.

         *
         * In version 6.0.4: added required
         * In version 6.0.2: removed required
         * In version 6.0.1: added required
         */
        type:IAttributeType;
    }

    /**
     * In version 6.2.0: deleted
     * In version 6.0.4: deprecated
     * In version 6.0.1: introduced
     */
    export class Attribute extends internal.Element implements IAttribute {
        model:IModel;
        public static typeName = "DomainModels_simple$Attribute";

        public container:Entity;
        private __name = new internal.PrimitiveProperty<string>(Attribute, this, "name", "", internal.PrimitiveTypeEnum.String);
        public get name():string { return this.__name.get(); }
        public set name(newValue:string) { this.__name.set(newValue); }
        private __dataStorageGuid = new internal.PrimitiveProperty<string>(Attribute, this, "dataStorageGuid", "", internal.PrimitiveTypeEnum.Guid);
        public get dataStorageGuid():string { return this.__dataStorageGuid.get(); }
        public set dataStorageGuid(newValue:string) { this.__dataStorageGuid.set(newValue); }
        private __type = new internal.PartProperty<AttributeType>(Attribute, this, "type", null, true);
        /**
         * In version 6.0.4: added required
         * In version 6.0.2: removed required
         * In version 6.0.1: added required
         */
        public get type():AttributeType { return this.__type.get(); }
        public set type(newValue:AttributeType) { this.__type.set(newValue); }
        private __documentation = new internal.PrimitiveProperty<string>(Attribute, this, "documentation", "", internal.PrimitiveTypeEnum.String);
        public get documentation():string { return this.__documentation.get(); }
        public set documentation(newValue:string) { this.__documentation.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.1",
          "deprecated" : "6.0.4",
          "deprecationMessage" : "Use Attribute2 instead",
          "deleted" : "6.2.0",
          "deletionMessage" : "Attribute2 is superior",
          "properties" : {
            "name" : {
              "public" : {
                "currentValue" : true
              }
            },
            "type" : {
              "public" : {
                "currentValue" : true
              },
              "required" : {
                "currentValue" : true,
                "changedIn" : [ "6.0.4", "6.0.2", "6.0.1" ]
              }
            }
          },
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new Attribute() cannot be invoked directly, please use 'model.domainmodels_simple.createAttribute()'");
        }

        /*
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * The new Attribute will be automatically stored in the 'attributes' property of the parent Entity element passed as argument.
         */
        public static createIn(container:Entity):Attribute {
            return internal.instancehelpers.createElement(container, Attribute, "attributes", true);
        }

        /*
         * Creates and returns a new Attribute instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):Attribute {
            return internal.instancehelpers.createElement(model, Attribute);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
            this.dataStorageGuid = utils.randomUuid();
            this.type = StringAttributeType.create(this.model);
        }

    }

    /**
     * In version 6.0.4: introduced, added public
     */
    export interface IAttribute2 extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():Attribute2;
        load(callback:(element:Attribute2)=>void);
        name:string;
    }

    /**
     * In version 6.0.4: introduced, added public
     */
    export class Attribute2 extends internal.Element implements IAttribute2 {
        model:IModel;
        public static typeName = "DomainModels_simple$Attribute2";

        public container:Entity;
        private __name = new internal.PrimitiveProperty<string>(Attribute2, this, "name", "", internal.PrimitiveTypeEnum.String);
        public get name():string { return this.__name.get(); }
        public set name(newValue:string) { this.__name.set(newValue); }
        private __coolNewThingy = new internal.PrimitiveProperty<string>(Attribute2, this, "coolNewThingy", "", internal.PrimitiveTypeEnum.String);
        public get coolNewThingy():string { return this.__coolNewThingy.get(); }
        public set coolNewThingy(newValue:string) { this.__coolNewThingy.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.4",
          "properties" : {
            "name" : {
              "public" : {
                "currentValue" : true
              }
            }
          },
          "public" : {
            "currentValue" : true,
            "changedIn" : [ "6.0.4" ]
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new Attribute2() cannot be invoked directly, please use 'model.domainmodels_simple.createAttribute2()'");
        }

        /*
         * Creates and returns a new Attribute2 instance in the SDK and on the server.
         * The new Attribute2 will be automatically stored in the 'attributes2' property of the parent Entity element passed as argument.
         */
        public static createIn(container:Entity):Attribute2 {
            return internal.instancehelpers.createElement(container, Attribute2, "attributes2", true);
        }

        /*
         * Creates and returns a new Attribute2 instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):Attribute2 {
            return internal.instancehelpers.createElement(model, Attribute2);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IAttributeType extends internal.IElement {
        model:IModel;
        container:IAttribute;
        load():AttributeType;
        load(callback:(element:AttributeType)=>void);
    }

    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    export abstract class AttributeType extends internal.Element implements IAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$AttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new AttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createAttributeType()'");
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface INumericAttributeTypeBase extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():NumericAttributeTypeBase;
        load(callback:(element:NumericAttributeTypeBase)=>void);
    }

    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    export abstract class NumericAttributeTypeBase extends AttributeType implements INumericAttributeTypeBase {
        model:IModel;
        public static typeName = "DomainModels_simple$NumericAttributeTypeBase";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new NumericAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels_simple.createNumericAttributeTypeBase()'");
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IIntegerAttributeTypeBase extends INumericAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():IntegerAttributeTypeBase;
        load(callback:(element:IntegerAttributeTypeBase)=>void);
    }

    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    export abstract class IntegerAttributeTypeBase extends NumericAttributeTypeBase implements IIntegerAttributeTypeBase {
        model:IModel;
        public static typeName = "DomainModels_simple$IntegerAttributeTypeBase";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new IntegerAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels_simple.createIntegerAttributeTypeBase()'");
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IAutoNumberAttributeType extends IIntegerAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():AutoNumberAttributeType;
        load(callback:(element:AutoNumberAttributeType)=>void);
    }

    export class AutoNumberAttributeType extends IntegerAttributeTypeBase implements IAutoNumberAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$AutoNumberAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new AutoNumberAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createAutoNumberAttributeType()'");
        }

        /*
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * The new AutoNumberAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):AutoNumberAttributeType {
            return internal.instancehelpers.createElement(container, AutoNumberAttributeType, "type", false);
        }

        /*
         * Creates and returns a new AutoNumberAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):AutoNumberAttributeType {
            return internal.instancehelpers.createElement(model, AutoNumberAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IBinaryAttributeType extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():BinaryAttributeType;
        load(callback:(element:BinaryAttributeType)=>void);
    }

    export class BinaryAttributeType extends AttributeType implements IBinaryAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$BinaryAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new BinaryAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createBinaryAttributeType()'");
        }

        /*
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * The new BinaryAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):BinaryAttributeType {
            return internal.instancehelpers.createElement(container, BinaryAttributeType, "type", false);
        }

        /*
         * Creates and returns a new BinaryAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):BinaryAttributeType {
            return internal.instancehelpers.createElement(model, BinaryAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IBooleanAttributeType extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():BooleanAttributeType;
        load(callback:(element:BooleanAttributeType)=>void);
    }

    export class BooleanAttributeType extends AttributeType implements IBooleanAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$BooleanAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new BooleanAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createBooleanAttributeType()'");
        }

        /*
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * The new BooleanAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):BooleanAttributeType {
            return internal.instancehelpers.createElement(container, BooleanAttributeType, "type", false);
        }

        /*
         * Creates and returns a new BooleanAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):BooleanAttributeType {
            return internal.instancehelpers.createElement(model, BooleanAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IDecimalAttributeTypeBase extends INumericAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():DecimalAttributeTypeBase;
        load(callback:(element:DecimalAttributeTypeBase)=>void);
    }

    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    export abstract class DecimalAttributeTypeBase extends NumericAttributeTypeBase implements IDecimalAttributeTypeBase {
        model:IModel;
        public static typeName = "DomainModels_simple$DecimalAttributeTypeBase";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new DecimalAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels_simple.createDecimalAttributeTypeBase()'");
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IFloatAttributeTypeBase extends IDecimalAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():FloatAttributeTypeBase;
        load(callback:(element:FloatAttributeTypeBase)=>void);
    }

    /**
     * Warning: this class represents an abstract and non-instantiable concept in the meta model.
     * You should _not_ try to instantiate this class directly, but instantiate one of its concrete/non-abstract sub classes instead.
     * Instantiating this class is possible in pure JavaScript, but there's no guarantee the result will be at all useful.
     */
    export abstract class FloatAttributeTypeBase extends DecimalAttributeTypeBase implements IFloatAttributeTypeBase {
        model:IModel;
        public static typeName = "DomainModels_simple$FloatAttributeTypeBase";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new FloatAttributeTypeBase() cannot be invoked directly, please use 'model.domainmodels_simple.createFloatAttributeTypeBase()'");
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface ICurrencyAttributeType extends IFloatAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():CurrencyAttributeType;
        load(callback:(element:CurrencyAttributeType)=>void);
    }

    export class CurrencyAttributeType extends FloatAttributeTypeBase implements ICurrencyAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$CurrencyAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new CurrencyAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createCurrencyAttributeType()'");
        }

        /*
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * The new CurrencyAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):CurrencyAttributeType {
            return internal.instancehelpers.createElement(container, CurrencyAttributeType, "type", false);
        }

        /*
         * Creates and returns a new CurrencyAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):CurrencyAttributeType {
            return internal.instancehelpers.createElement(model, CurrencyAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IDateTimeAttributeType extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():DateTimeAttributeType;
        load(callback:(element:DateTimeAttributeType)=>void);
    }

    export class DateTimeAttributeType extends AttributeType implements IDateTimeAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$DateTimeAttributeType";

        public container:Attribute;
        private __localizeDate = new internal.PrimitiveProperty<boolean>(DateTimeAttributeType, this, "localizeDate", false, internal.PrimitiveTypeEnum.Boolean);
        public get localizeDate():boolean { return this.__localizeDate.get(); }
        public set localizeDate(newValue:boolean) { this.__localizeDate.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new DateTimeAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createDateTimeAttributeType()'");
        }

        /*
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * The new DateTimeAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):DateTimeAttributeType {
            return internal.instancehelpers.createElement(container, DateTimeAttributeType, "type", false);
        }

        /*
         * Creates and returns a new DateTimeAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):DateTimeAttributeType {
            return internal.instancehelpers.createElement(model, DateTimeAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
            this.localizeDate = true;
        }

    }

    export interface IDecimalAttributeType extends IDecimalAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():DecimalAttributeType;
        load(callback:(element:DecimalAttributeType)=>void);
    }

    export class DecimalAttributeType extends DecimalAttributeTypeBase implements IDecimalAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$DecimalAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new DecimalAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createDecimalAttributeType()'");
        }

        /*
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * The new DecimalAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):DecimalAttributeType {
            return internal.instancehelpers.createElement(container, DecimalAttributeType, "type", false);
        }

        /*
         * Creates and returns a new DecimalAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):DecimalAttributeType {
            return internal.instancehelpers.createElement(model, DecimalAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    /**
     * In version 6.0.1: introduced
     */
    export interface IDomainModel extends internal.IModelUnit {
        model:IModel;
        container:IProject;
        load():DomainModel;
        load(callback:(element:DomainModel)=>void);
        name:string;
        entities:internal.IList<IEntity>;
    }

    /**
     * In version 6.0.1: introduced
     */
    export class DomainModel extends internal.ModelUnit implements IDomainModel {
        model:IModel;
        public static typeName = "DomainModels_simple$DomainModel";

        public container:Project;
        private __name = new internal.PrimitiveProperty<string>(DomainModel, this, "name", "", internal.PrimitiveTypeEnum.String);
        public get name():string { return this.__name.get(); }
        public set name(newValue:string) { this.__name.set(newValue); }
        private __documentation = new internal.PrimitiveProperty<string>(DomainModel, this, "documentation", "", internal.PrimitiveTypeEnum.String);
        public get documentation():string { return this.__documentation.get(); }
        public set documentation(newValue:string) { this.__documentation.set(newValue); }
        private __entities = new internal.PartListProperty<Entity>(DomainModel, this, "entities", []);
        public get entities():internal.IList<Entity> { return this.__entities.get(); }
        public set entities(newValue:internal.IList<Entity>) { this.__entities.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.1",
          "properties" : {
            "name" : {
              "public" : {
                "currentValue" : true
              }
            },
            "entities" : {
              "public" : {
                "currentValue" : true
              }
            }
          }
        }, internal.StructureType.ModelUnit);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, container:IProject) {
            super(model, typeName, id, isPartial, container);
            this._containmentName = "domainModel";
        }

        /**
         * Creates a new DomainModel unit in the SDK and on the server.
         * Expects one argument, a Project in which this unit is contained.
         */
        public static createIn(container:IProject):DomainModel {
            return internal.instancehelpers.createUnit(container, DomainModel);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    /**
     * In version 6.0.2: introduced, removed experimental
     * In version 6.0.1: added experimental
     * In version 6.0.0: 
     */
    export interface IEntity extends internal.IElement {
        model:IModel;
        container:IDomainModel;
        load():Entity;
        load(callback:(element:Entity)=>void);
        /**
         * In version 6.0.5: added public, added required
         * In version 6.0.2: removed public, removed required
         * In version 6.0.1: added public, added required
         */
        name:string;
        /**
         * In version 6.2.0: deleted
         * In version 6.0.4: deprecated
         * In version 6.0.1: introduced
         */
        attributes:internal.IList<IAttribute>;
        /**
         * In version 6.0.4: introduced
         */
        attributes2:internal.IList<IAttribute2>;
        /**
         * In version 6.0.4: introduced
         */
        newThing:INewElement;
    }

    /**
     * In version 6.0.2: introduced, removed experimental
     * In version 6.0.1: added experimental
     * In version 6.0.0: 
     */
    export class Entity extends internal.Element implements IEntity {
        model:IModel;
        public static typeName = "DomainModels_simple$Entity";

        public container:DomainModel;
        private __name = new internal.PrimitiveProperty<string>(Entity, this, "name", "", internal.PrimitiveTypeEnum.String);
        /**
         * In version 6.0.5: added public, added required
         * In version 6.0.2: removed public, removed required
         * In version 6.0.1: added public, added required
         */
        public get name():string { return this.__name.get(); }
        public set name(newValue:string) { this.__name.set(newValue); }
        private __location = new internal.PrimitiveProperty<common.IPoint>(Entity, this, "location", { x:0, y:0 }, internal.PrimitiveTypeEnum.Point);
        public get location():common.IPoint { return this.__location.get(); }
        public set location(newValue:common.IPoint) { this.__location.set(newValue); }
        private __documentation = new internal.PrimitiveProperty<string>(Entity, this, "documentation", "", internal.PrimitiveTypeEnum.String);
        public get documentation():string { return this.__documentation.get(); }
        public set documentation(newValue:string) { this.__documentation.set(newValue); }
        private __attributes = new internal.PartListProperty<Attribute>(Entity, this, "attributes", []);
        /**
         * In version 6.2.0: deleted
         * In version 6.0.4: deprecated
         * In version 6.0.1: introduced
         */
        public get attributes():internal.IList<Attribute> { return this.__attributes.get(); }
        public set attributes(newValue:internal.IList<Attribute>) { this.__attributes.set(newValue); }
        private __attributes2 = new internal.PartListProperty<Attribute2>(Entity, this, "attributes2", []);
        /**
         * In version 6.0.4: introduced
         */
        public get attributes2():internal.IList<Attribute2> { return this.__attributes2.get(); }
        public set attributes2(newValue:internal.IList<Attribute2>) { this.__attributes2.set(newValue); }
        private __superCool = new internal.PartProperty<SuperCoolElement>(Entity, this, "superCool", null, false);
        public get superCool():SuperCoolElement { return this.__superCool.get(); }
        public set superCool(newValue:SuperCoolElement) { this.__superCool.set(newValue); }
        private __newThing = new internal.PartProperty<NewElement>(Entity, this, "newThing", null, false);
        /**
         * In version 6.0.4: introduced
         */
        public get newThing():NewElement { return this.__newThing.get(); }
        public set newThing(newValue:NewElement) { this.__newThing.set(newValue); }
        private __nonUsedElement = new internal.PartProperty<VeryNewElement>(Entity, this, "nonUsedElement", null, false);
        /**
         * In version 6.0.5: introduced
         */
        public get nonUsedElement():VeryNewElement { return this.__nonUsedElement.get(); }
        public set nonUsedElement(newValue:VeryNewElement) { this.__nonUsedElement.set(newValue); }
        private __experimentalElemInModel = new internal.PartProperty<ExperimentalElement>(Entity, this, "experimentalElemInModel", null, false);
        /**
         * In version 6.0.4: introduced
         */
        public get experimentalElemInModel():ExperimentalElement { return this.__experimentalElemInModel.get(); }
        public set experimentalElemInModel(newValue:ExperimentalElement) { this.__experimentalElemInModel.set(newValue); }
        private __experimentalElemNotInModel = new internal.PartProperty<ExperimentalElement>(Entity, this, "experimentalElemNotInModel", null, false);
        /**
         * In version 6.0.4: introduced
         */
        public get experimentalElemNotInModel():ExperimentalElement { return this.__experimentalElemNotInModel.get(); }
        public set experimentalElemNotInModel(newValue:ExperimentalElement) { this.__experimentalElemNotInModel.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.2",
          "properties" : {
            "name" : {
              "public" : {
                "currentValue" : true,
                "changedIn" : [ "6.0.5", "6.0.2", "6.0.1" ]
              }
            },
            "attributes" : {
              "introduced" : "6.0.1",
              "deprecated" : "6.0.4",
              "deprecationMessage" : "Use Attribute 2 instead",
              "deleted" : "6.2.0",
              "deletionMessage" : "Attribute2 is superior",
              "public" : {
                "currentValue" : true
              }
            },
            "attributes2" : {
              "introduced" : "6.0.4",
              "public" : {
                "currentValue" : true
              }
            },
            "newThing" : {
              "introduced" : "6.0.4",
              "public" : {
                "currentValue" : true
              }
            },
            "nonUsedElement" : {
              "introduced" : "6.0.5"
            },
            "experimentalElemInModel" : {
              "introduced" : "6.0.4"
            },
            "experimentalElemNotInModel" : {
              "introduced" : "6.0.4"
            }
          },
          "public" : {
            "currentValue" : true
          },
          "experimental" : {
            "currentValue" : false,
            "changedIn" : [ "6.0.2", "6.0.1" ]
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new Entity() cannot be invoked directly, please use 'model.domainmodels_simple.createEntity()'");
        }

        /*
         * Creates and returns a new Entity instance in the SDK and on the server.
         * The new Entity will be automatically stored in the 'entities' property of the parent DomainModel element passed as argument.
         */
        public static createIn(container:DomainModel):Entity {
            return internal.instancehelpers.createElement(container, Entity, "entities", true);
        }

        /*
         * Creates and returns a new Entity instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):Entity {
            return internal.instancehelpers.createElement(model, Entity);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
            this.name = "MyEntity";
        }

    }

    /**
     * In version 6.0.9: added experimental
     * In version 6.0.7: removed experimental
     * In version 6.0.6: added experimental
     * In version 6.0.4: introduced
     */
    export interface IExperimentalElement extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():ExperimentalElement;
        load(callback:(element:ExperimentalElement)=>void);
    }

    /**
     * In version 6.0.9: added experimental
     * In version 6.0.7: removed experimental
     * In version 6.0.6: added experimental
     * In version 6.0.4: introduced
     */
    export class ExperimentalElement extends internal.Element implements IExperimentalElement {
        model:IModel;
        public static typeName = "DomainModels_simple$ExperimentalElement";

        public container:Entity;
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.4",
          "experimental" : {
            "currentValue" : true,
            "changedIn" : [ "6.0.9", "6.0.7", "6.0.6" ]
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new ExperimentalElement() cannot be invoked directly, please use 'model.domainmodels_simple.createExperimentalElement()'");
        }


        /*
         * Creates and returns a new ExperimentalElement instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):ExperimentalElement {
            return internal.instancehelpers.createElement(model, ExperimentalElement);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IFloatAttributeType extends IFloatAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():FloatAttributeType;
        load(callback:(element:FloatAttributeType)=>void);
    }

    export class FloatAttributeType extends FloatAttributeTypeBase implements IFloatAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$FloatAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new FloatAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createFloatAttributeType()'");
        }

        /*
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * The new FloatAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):FloatAttributeType {
            return internal.instancehelpers.createElement(container, FloatAttributeType, "type", false);
        }

        /*
         * Creates and returns a new FloatAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):FloatAttributeType {
            return internal.instancehelpers.createElement(model, FloatAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IHashedStringAttributeType extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():HashedStringAttributeType;
        load(callback:(element:HashedStringAttributeType)=>void);
    }

    export class HashedStringAttributeType extends AttributeType implements IHashedStringAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$HashedStringAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new HashedStringAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createHashedStringAttributeType()'");
        }

        /*
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * The new HashedStringAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):HashedStringAttributeType {
            return internal.instancehelpers.createElement(container, HashedStringAttributeType, "type", false);
        }

        /*
         * Creates and returns a new HashedStringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):HashedStringAttributeType {
            return internal.instancehelpers.createElement(model, HashedStringAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IIntegerAttributeType extends IIntegerAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():IntegerAttributeType;
        load(callback:(element:IntegerAttributeType)=>void);
    }

    export class IntegerAttributeType extends IntegerAttributeTypeBase implements IIntegerAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$IntegerAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new IntegerAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createIntegerAttributeType()'");
        }

        /*
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * The new IntegerAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):IntegerAttributeType {
            return internal.instancehelpers.createElement(container, IntegerAttributeType, "type", false);
        }

        /*
         * Creates and returns a new IntegerAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):IntegerAttributeType {
            return internal.instancehelpers.createElement(model, IntegerAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface ILongAttributeType extends IIntegerAttributeTypeBase {
        model:IModel;
        container:IAttribute;
        load():LongAttributeType;
        load(callback:(element:LongAttributeType)=>void);
    }

    export class LongAttributeType extends IntegerAttributeTypeBase implements ILongAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$LongAttributeType";

        public container:Attribute;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new LongAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createLongAttributeType()'");
        }

        /*
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * The new LongAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):LongAttributeType {
            return internal.instancehelpers.createElement(container, LongAttributeType, "type", false);
        }

        /*
         * Creates and returns a new LongAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):LongAttributeType {
            return internal.instancehelpers.createElement(model, LongAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    /**
     * In version 6.0.4: introduced
     */
    export interface INewElement extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():NewElement;
        load(callback:(element:NewElement)=>void);
        /**
         * In version 6.0.9: added public
         * In version 6.0.7: removed public
         * In version 6.0.6: added public
         */
        myNewProp:string;
    }

    /**
     * In version 6.0.4: introduced
     */
    export class NewElement extends internal.Element implements INewElement {
        model:IModel;
        public static typeName = "DomainModels_simple$NewElement";

        public container:Entity;
        private __myProp = new internal.PartProperty<NewElement2>(NewElement, this, "myProp", null, true);
        /**
         * In version 6.0.9: added required
         * In version 6.0.7: removed required
         * In version 6.0.6: added required
         */
        public get myProp():NewElement2 { return this.__myProp.get(); }
        public set myProp(newValue:NewElement2) { this.__myProp.set(newValue); }
        private __myNewProp = new internal.PrimitiveProperty<string>(NewElement, this, "myNewProp", "", internal.PrimitiveTypeEnum.String);
        /**
         * In version 6.0.9: added public
         * In version 6.0.7: removed public
         * In version 6.0.6: added public
         */
        public get myNewProp():string { return this.__myNewProp.get(); }
        public set myNewProp(newValue:string) { this.__myNewProp.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "introduced" : "6.0.4",
          "properties" : {
            "myProp" : {
              "required" : {
                "currentValue" : true,
                "changedIn" : [ "6.0.9", "6.0.7", "6.0.6" ]
              }
            },
            "myNewProp" : {
              "public" : {
                "currentValue" : true,
                "changedIn" : [ "6.0.9", "6.0.7", "6.0.6" ]
              }
            }
          },
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new NewElement() cannot be invoked directly, please use 'model.domainmodels_simple.createNewElement()'");
        }

        /*
         * Creates and returns a new NewElement instance in the SDK and on the server.
         * The new NewElement will be automatically stored in the 'newThing' property of the parent Entity element passed as argument.
         */
        public static createIn(container:Entity):NewElement {
            return internal.instancehelpers.createElement(container, NewElement, "newThing", false);
        }

        /*
         * Creates and returns a new NewElement instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):NewElement {
            return internal.instancehelpers.createElement(model, NewElement);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
            this.myProp = NewElement2.create(this.model);
        }

    }

    export interface INewElement2 extends internal.IElement {
        model:IModel;
        container:INewElement;
        load():NewElement2;
        load(callback:(element:NewElement2)=>void);
    }

    export class NewElement2 extends internal.Element implements INewElement2 {
        model:IModel;
        public static typeName = "DomainModels_simple$NewElement2";

        public container:NewElement;
        public static versionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new NewElement2() cannot be invoked directly, please use 'model.domainmodels_simple.createNewElement2()'");
        }

        /*
         * Creates and returns a new NewElement2 instance in the SDK and on the server.
         * The new NewElement2 will be automatically stored in the 'myProp' property of the parent NewElement element passed as argument.
         */
        public static createIn(container:NewElement):NewElement2 {
            return internal.instancehelpers.createElement(container, NewElement2, "myProp", false);
        }

        /*
         * Creates and returns a new NewElement2 instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):NewElement2 {
            return internal.instancehelpers.createElement(model, NewElement2);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IProject extends internal.IStructuralUnit {
        model:IModel;
        domainModel:IDomainModel;
    }

    export class Project extends internal.StructuralUnit implements IProject {
        model:IModel;
        public static typeName = "DomainModels_simple$Project";

        private __domainModel = new internal.StructuralChildProperty<IDomainModel>(Project, this, "domainModel", null);
        public get domainModel():IDomainModel { return this.__domainModel.get(); }
        public set domainModel(newValue:IDomainModel) { this.__domainModel.set(newValue); }
        public static versionInfo = new StructureVersionInfo({ }, internal.StructureType.StructuralUnit);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, container:internal.IStructuralUnit) {
            super(model, typeName, id, isPartial, container);
            this._containmentName = "";
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IStringAttributeType extends IAttributeType {
        model:IModel;
        container:IAttribute;
        load():StringAttributeType;
        load(callback:(element:StringAttributeType)=>void);
    }

    export class StringAttributeType extends AttributeType implements IStringAttributeType {
        model:IModel;
        public static typeName = "DomainModels_simple$StringAttributeType";

        public container:Attribute;
        private __length = new internal.PrimitiveProperty<number>(StringAttributeType, this, "length", 0, internal.PrimitiveTypeEnum.Integer);
        public get length():number { return this.__length.get(); }
        public set length(newValue:number) { this.__length.set(newValue); }
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : true
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new StringAttributeType() cannot be invoked directly, please use 'model.domainmodels_simple.createStringAttributeType()'");
        }

        /*
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * The new StringAttributeType will be automatically stored in the 'type' property of the parent Attribute element passed as argument.
         */
        public static createIn(container:Attribute):StringAttributeType {
            return internal.instancehelpers.createElement(container, StringAttributeType, "type", false);
        }

        /*
         * Creates and returns a new StringAttributeType instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):StringAttributeType {
            return internal.instancehelpers.createElement(model, StringAttributeType);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
            this.length = 200;
        }

    }

    /**
     * In version 6.0.4: removed public, removed experimental
     * In version 6.0.1: added public, added experimental
     */
    export interface ISuperCoolElement extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():SuperCoolElement;
        load(callback:(element:SuperCoolElement)=>void);
    }

    /**
     * In version 6.0.4: removed public, removed experimental
     * In version 6.0.1: added public, added experimental
     */
    export class SuperCoolElement extends internal.Element implements ISuperCoolElement {
        model:IModel;
        public static typeName = "DomainModels_simple$SuperCoolElement";

        public container:Entity;
        public static versionInfo = new StructureVersionInfo({
          "public" : {
            "currentValue" : false,
            "changedIn" : [ "6.0.4", "6.0.1" ]
          },
          "experimental" : {
            "currentValue" : false,
            "changedIn" : [ "6.0.4", "6.0.1" ]
          }
        }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new SuperCoolElement() cannot be invoked directly, please use 'model.domainmodels_simple.createSuperCoolElement()'");
        }

        /*
         * Creates and returns a new SuperCoolElement instance in the SDK and on the server.
         * The new SuperCoolElement will be automatically stored in the 'superCool' property of the parent Entity element passed as argument.
         */
        public static createIn(container:Entity):SuperCoolElement {
            return internal.instancehelpers.createElement(container, SuperCoolElement, "superCool", false);
        }

        /*
         * Creates and returns a new SuperCoolElement instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):SuperCoolElement {
            return internal.instancehelpers.createElement(model, SuperCoolElement);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }

    export interface IVeryNewElement extends internal.IElement {
        model:IModel;
        container:IEntity;
        load():VeryNewElement;
        load(callback:(element:VeryNewElement)=>void);
    }

    export class VeryNewElement extends internal.Element implements IVeryNewElement {
        model:IModel;
        public static typeName = "DomainModels_simple$VeryNewElement";

        public container:Entity;
        public static versionInfo = new StructureVersionInfo({ }, internal.StructureType.Element);

        constructor(model:internal.AbstractModel, typeName:string, id:string, isPartial:boolean, unit:internal.ModelUnit, container:internal.AbstractElement) {
            super(model, typeName, id, isPartial, unit, container);
            if (arguments.length < 4)
                throw new Error("new VeryNewElement() cannot be invoked directly, please use 'model.domainmodels_simple.createVeryNewElement()'");
        }

        /*
         * Creates and returns a new VeryNewElement instance in the SDK and on the server.
         * The new VeryNewElement will be automatically stored in the 'nonUsedElement' property of the parent Entity element passed as argument.
         */
        public static createIn(container:Entity):VeryNewElement {
            return internal.instancehelpers.createElement(container, VeryNewElement, "nonUsedElement", false);
        }

        /*
         * Creates and returns a new VeryNewElement instance in the SDK and on the server.
         * Expects one argument: the IModel object the instance will "live on".
         * After creation, assign or add this instance to a property that accepts this kind of objects.
         */
        public static create(model:IModel):VeryNewElement {
            return internal.instancehelpers.createElement(model, VeryNewElement);
        }

        _initializeDefaultProperties() {
            super._initializeDefaultProperties();
        }

    }
}


import {IModel} from './base-model'; 
