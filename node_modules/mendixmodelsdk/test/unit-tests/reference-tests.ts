/// <reference path="../test-typings.d.ts"/>

import {domainmodels, IModel} from "mendixmodelsdk";
import {assert} from 'chai';
import {CompanyExpensesStubClient} from '../helpers/stub-model-client';
import {createSdkClient} from '../helpers/sdk-client-helper';
import lodash = require('lodash');


const domainModelUnitId = CompanyExpensesStubClient.domainModelUnitId;

describe('meta model checks', () => {

	it('should load units and domain model', done => {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			assert.equal(m.allDomainModels().length, 3);
			const d = m.allDomainModels()[1];
			assert.equal(d.moduleName, "Expenses");
			done();
		}, done);
	});

	it('should create texts for validation rules with default values', done => {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			assert.equal(m.allDomainModels().length, 3);
			const d = m.allDomainModels()[1];
			assert.equal(d.moduleName, "Expenses");
			d.load(dm => {
				const e = dm.entities[0];
				domainmodels.ValidationRule.createIn(e);

				const vr = e.validationRules[e.validationRules.length -1];
				const er = vr.errorMessage;
				assert.ok(er);
				assert.equal(er.translations.length, 1);
				const tl = vr.errorMessage.translations[0];
				assert.equal(tl.languageCode, "en_US");
				assert.equal(tl.text, "");

				m.closeConnection(() => {
					assert.deepEqual((<CompanyExpensesStubClient>m['_client']).deltas,
[
  {
    "deltaType": "CREATE_ELEMENT",
    "elementId": vr.id,
    "elementType": "DomainModels$ValidationRule",
    "parentId": e.id,
    "parentPropertyName": "validationRules",
    "unitId": dm.id
  },
  {
    "deltaType": "CREATE_ELEMENT",
    "elementId": er.id,
    "elementType": "Texts$Text",
    "parentId": vr.id,
    "parentPropertyName": "errorMessage",
    "unitId": dm.id
  },
  {
    "deltaType": "CREATE_ELEMENT",
    "elementId": tl.id,
    "elementType": "Texts$Translation",
    "parentId": er.id,
    "parentPropertyName": "translations",
    "unitId": dm.id
  },
  {
    "deltaType": "UPDATE_PROPERTY_VALUE",
    "elementId": tl.id,
    "mutator": {
      "mutatorType": "CHANGE",
      "value": "en_US"
    },
    "propertyName": "languageCode",
    "unitId": dm.id
  },
  {
    "deltaType": "CREATE_ELEMENT",
    "elementId": vr.ruleInfo.id,
    "elementType": "DomainModels$RequiredRuleInfo",
    "parentId": vr.id,
    "parentPropertyName": "ruleInfo",
    "unitId": dm.id
  },
]
					);
					done();
				});
			});
		}, done);
	});

	it('should resolve references by id', done => {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			const d = m.allDomainModels()[1];
			const assoc = d.associations[0];
			assert.equal(assoc.name, "Expense_ExpenseType");
			assert.equal(assoc.parent.name, "Expense");
			assert.equal(assoc.child.name, "ExpenseType");
			done();
		}, done);
	});

	it('should generate correct qualified names for attributes', done => {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			const d = m.allDomainModels()[1];
			const e = d.entities.find(e => e.name === "Expense");
			const attr = e.attributes.find(a => a.name === "Status");
			assert.ok(attr);
			assert.equal(attr.qualifiedName, "Expenses.Expense.Status");
			done();
		}, done);
	});

	it('should resolve references by name in interfaces', function(done) {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			const d = m.allDomainModels()[1];
			assert.equal(d.qualifiedName, "Expenses");
			const assoc = d.crossAssociations[0];
			assert.equal(assoc.name, "Conversion_User");
			assert.equal(assoc.parent.name, "Conversion");

			// TODO: only available once system module is available...
			// assert.equal(assoc.child.name, "User");

			const entity: domainmodels.IEntity = <domainmodels.IEntity> m.findEntityByQualifiedName("Expenses.Expense");
			const attr = lodash.find(entity.attributes, a => a.name === "Status");
			assert.ok(attr, "attr was not found");
			assert.ok((<domainmodels.EnumerationAttributeType>attr.type).enumeration, "enumeration was not resolved");
			assert.equal((<domainmodels.EnumerationAttributeType> attr.type).enumeration.name, "Expense_Status");

			done();
		}, done);
	});

	it('should resolve references by name in units', function(done) {
		this.timeout(0);
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			m.loadUnitById(domainModelUnitId, (d:domainmodels.DomainModel) => {
				const entity: domainmodels.Entity = <domainmodels.Entity> m.findEntityByQualifiedName("Expenses.Expense");
				const attr = lodash.find(entity.attributes, a => a.name === "Status");
				assert.ok(attr, "attr was not found");
				assert.ok((<domainmodels.EnumerationAttributeType>attr.type).enumeration, "enumeration was not resolved");
				assert.equal((<domainmodels.EnumerationAttributeType>attr.type).enumeration.name, "Expense_Status");
				assert.equal((<CompanyExpensesStubClient>m['_client']).deltas.length, 0);
				done();
			})
		}, done);
	});

	it('should handle bynamereferencelists', function(done) {
		this.timeout(0);
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			m.allDomainModels().filter(d => d.qualifiedName === "Expenses")[0].load(dm => {
				const unitId = dm.id;
				const module = dm.container;
				assert.equal(module.moduleSecurity.moduleRoles.length, 3);

				const managerRole = module.moduleSecurity.moduleRoles.find(mr => mr.name === "Manager");
				assert.equal(managerRole.qualifiedName, "Expenses.Manager");

				const employeeRole = module.moduleSecurity.moduleRoles.find(mr => mr.name === "Employee");
				assert.equal(employeeRole.qualifiedName, "Expenses.Employee");

				const entity = dm.entities.find(e => e.name === "ExpenseType");
				assert.equal(entity.accessRules.length, 2, "invalid amount of access rules");
				const ac = entity.accessRules[1];
				assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");

				assert.equal(ac.moduleRoles[1].qualifiedName, managerRole.qualifiedName);
				assert.equal(ac.moduleRoles[1], managerRole);

				ac.moduleRoles[0] = employeeRole;
				ac.moduleRoles.pop();
				assert.equal(ac.moduleRoles.length, 1, "invalid amount of module roles in access rule");
				ac.moduleRoles.unshift(managerRole);
				assert.equal(ac.moduleRoles.length, 2, "invalid amount of module roles in access rule");

				assert.throw(() => {
					ac.moduleRoles = <any>[employeeRole];
				}, "Illegal state: cannot re-assign list property - use push or splice instead");

				const elementId = "e2c13b7d-efa3-4f56-a7aa-8441fab9f3f6";
				m.closeConnection(() => {
					assert.deepEqual((<CompanyExpensesStubClient>m['_client']).deltas, [
						{
						  "deltaType": "UPDATE_PROPERTY_VALUE",
						  "elementId": elementId,
						  "mutator": {
						    "mutatorType": "CHANGE",
						    "updateIndex": 0,
						    "value": "Expenses.Employee"
						  },
						  "propertyName": "moduleRoles",
						  "unitId": unitId
						},
						{
						  "deltaType": "UPDATE_PROPERTY_VALUE",
						  "elementId": elementId,
						  "mutator": {
						    "mutatorType": "REMOVE",
						    "removalIndex": 2
						  },
						  "propertyName": "moduleRoles",
						  "unitId": unitId,
						},
						{
						  "deltaType": "UPDATE_PROPERTY_VALUE",
						  "elementId": elementId,
						  "mutator": {
						    "insertionIndex": 0,
						    "mutatorType": "ADD",
						    "value": "Expenses.Manager"
						  },
						  "propertyName": "moduleRoles",
						  "unitId": unitId
						}
					]);
					done();
				});

			})
		}, done);
	});

	const expectedContainmentExceptionMessage = `Cannot update property of '${domainmodels.Association.typeName}', the given object is not yet part of a unit. Please add the object to an unit first`;

	it('should fail on references to objects not added to the tree yet', function(done) {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			m.loadUnitById(domainModelUnitId, (d:domainmodels.DomainModel) => {
				const entity = domainmodels.Entity.create(m);
				const assoc = domainmodels.Association.create(m);
				try {
					assoc.parent = entity;
				}
				catch (e) {
					assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
					return void done();
				}
				return void done(new Error("expected exception"));
			});
		}, done);
	});


	it('should handle by name reference lists', function(done) {
		createSdkClient().openWorkingCopy("1", (m:IModel) => {
			m.loadUnitById(domainModelUnitId, (d:domainmodels.DomainModel) => {
				const entity = domainmodels.Entity.create(m);
				const assoc = domainmodels.Association.create(m);
				try {
					assoc.parent = entity;
				}
				catch (e) {
					assert.isTrue(("" + e).indexOf(expectedContainmentExceptionMessage) !== -1, "exception message");
					return void done();
				}
				return void done(new Error("expected exception"));
			});
		}, done);
	});

	it('should pick up renames and deletes of elements that are refered by name', function(done) {
		createSdkClient().openWorkingCopy("1", model => {
			model.loadUnitById(domainModelUnitId, (d:domainmodels.DomainModel) => {
				// create a cross association (in the same module, but that's ok for now...):
				const crossAssoc = domainmodels.CrossAssociation.create(model);

				d.crossAssociations.unshift(crossAssoc);
				const tempUserEntity = lodash.find(d.entities, ent => ent.name === "TempUser");
				assert.ok(tempUserEntity);

				const amountOfEntities = d.entities.length;
				crossAssoc.parent = d.entities[0];
				crossAssoc.child = tempUserEntity; // This entity has no assocs, so can be deleted easily
				assert.equal(crossAssoc.childQualifiedName, "Expenses.TempUser");

				// rename an entity:
				tempUserEntity.name = "Renamed";
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				// delete that entity:
				tempUserEntity.delete();
				assert.equal(d.entities.length, amountOfEntities -1);

				// name should be saved, but reference should not resolve anymore:
				assert.equal((<any>crossAssoc).__child.observableValue.referenceId, "Expenses.Renamed");
				assert.equal(crossAssoc.child, null);
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				// Create new entity, reference should be picked up automatically
				const newEntity = domainmodels.Entity.createIn(d);
				assert.equal(d.entities.length, amountOfEntities);
				newEntity.name = "Renamed";

				assert.equal((<any>crossAssoc).__child.observableValue.referenceId, "Expenses.Renamed");
				assert.equal(crossAssoc.child, newEntity);
				assert.equal(crossAssoc.childQualifiedName, "Expenses.Renamed");

				model.closeConnection(() => {
					// verify the deltas created during the process:
					const deltas = (<CompanyExpensesStubClient>model['_client']).deltas.slice();
					assert.deepEqual(deltas, [
					    {
					        "parentId": domainModelUnitId,
					        "elementType": domainmodels.CrossAssociation.typeName,
					        "parentPropertyName": "crossAssociations",
					        "deltaType": "CREATE_ELEMENT",
					        "unitId": domainModelUnitId,
					        "elementId": crossAssoc.id
					    },
						{
					        "unitId": domainModelUnitId,
					        "elementId": crossAssoc.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "dataStorageGuid",
					        "mutator": {
					            "value": crossAssoc.dataStorageGuid,
					            "mutatorType": "CHANGE"
					        }
					    },
						{
						    "parentId": crossAssoc.id,
						    "elementType": domainmodels.AssociationDeleteBehavior.typeName,
						    "parentPropertyName": "deleteBehavior",
						    "deltaType": "CREATE_ELEMENT",
						    "unitId": domainModelUnitId,
						    "elementId": crossAssoc.deleteBehavior.id
						},
					    {
					        "unitId": domainModelUnitId,
					        "elementId": crossAssoc.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "parent",
					        "mutator": {
					            "value": "48345255-c0be-4304-803b-1e53c658eb93",
					            "mutatorType": "CHANGE"
					        }
					    },
					    {
					        "unitId": domainModelUnitId,
					        "elementId": crossAssoc.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "child",
					        "mutator": {
					            "value": "Expenses.TempUser",
					            "mutatorType": "CHANGE"
					        }
					    },
					    {
					        "unitId": domainModelUnitId,
					        "elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "name",
					        "mutator": {
					            "value": "Renamed",
					            "mutatorType": "CHANGE"
					        }
					    },
					    {
					        "unitId": domainModelUnitId,
					        "elementId": "863c0fa3-30c2-4f8f-9d4f-5654ad3d1b03",
					        "deltaType": "DELETE_ELEMENT"
					    },
					    {
					        "parentId": domainModelUnitId,
					        "elementType": domainmodels.Entity.typeName,
					        "parentPropertyName": "entities",
					        "deltaType": "CREATE_ELEMENT",
					        "unitId": domainModelUnitId,
					        "elementId": newEntity.id
					    },
						{
					        "unitId": domainModelUnitId,
					        "elementId": newEntity.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "dataStorageGuid",
					        "mutator": {
					            "value": newEntity.dataStorageGuid,
					            "mutatorType": "CHANGE"
					        }
					    },
					    {
					        "unitId": domainModelUnitId,
					        "parentId": newEntity.id,
					        "elementType": domainmodels.NoGeneralization.typeName,
					        "parentPropertyName": "generalization",
					        "deltaType": "CREATE_ELEMENT",
					        "elementId": newEntity.generalization.id
					    },
					    {
					        "unitId": domainModelUnitId,
					        "elementId": newEntity.generalization.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "persistable",
					        "mutator": {
					            "value": true,
					            "mutatorType": "CHANGE"
					        }
					    },
					    {
					        "unitId": domainModelUnitId,
					        "elementId": newEntity.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "name",
					        "mutator": {
					            "value": "Renamed",
					            "mutatorType": "CHANGE"
					        }
					    }
					]);

					done();
				});
			});
		}, done);
	});

	it('setting an optional by-id reference to null should clear it (but not remove the referred element)', function(done) {
		this.timeout(0);	// avoid debug session being aborted
		createSdkClient().openWorkingCopy("1", model => {
			model.loadUnitById(domainModelUnitId, (d:domainmodels.DomainModel) => {
				const entity = d.entities[0];
				const attribute1 = entity.attributes[0];

				const index = domainmodels.Index.createIn(entity);
				const indexedAttribute = domainmodels.IndexedAttribute.createIn(index);
				indexedAttribute.attribute = attribute1;
				assert.isNotNull(indexedAttribute.attribute);

				indexedAttribute.attribute = null;
				assert.isNull(indexedAttribute.attribute);	// also: no exception thrown
				assert.ok(entity.attributes[0]);
				assert.equal(entity.attributes[0].id, attribute1.id);

				model.closeConnection(() => {
					// verify the deltas created during the process:
					const lastDelta = (<CompanyExpensesStubClient>model['_client']).deltas.slice(-1)[0];
					assert.deepEqual(lastDelta,
					    {
					        "unitId": domainModelUnitId,
					        "elementId": indexedAttribute.id,
					        "deltaType": "UPDATE_PROPERTY_VALUE",
					        "propertyName": "attribute",
					        "mutator": {
					            "value": null,
					            "mutatorType": "CHANGE"
					        }
					    }
					);
					done();
				});
			});
		}, done);
	});

});
