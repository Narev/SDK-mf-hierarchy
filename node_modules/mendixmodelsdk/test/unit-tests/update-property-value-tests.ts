/// <reference path="../test-typings.d.ts"/>

import {pages, customwidgets, domainmodels, projects} from "mendixmodelsdk";
import {StubClient} from '../helpers/stub-model-client';
import {createSdkClient} from '../helpers/sdk-client-helper';
import {createSmallDomainModel} from '../helpers/small-domain-model-helper';
import {assert} from 'chai';


describe('update property values', () => {

    const client = createSdkClient();

    function createSmallPage(module:projects.IModule) {
        const page = pages.Page.createIn(module);
        const model = module.model;
        const widget = customwidgets.CustomWidget.create(model);
        const widgetType = widget.type = customwidgets.CustomWidgetType.create(model);
        const widgetObjectType = widgetType.objectType = customwidgets.WidgetObjectType.create(model);
        const widgetPropertyType = customwidgets.WidgetPropertyType.create(model);
        widgetObjectType.propertyTypes.push(widgetPropertyType);
        const valueType = widgetPropertyType.valueType = customwidgets.WidgetValueType.create(model);
        const argument = pages.LayoutCallArgument.create(model);
        argument.widget = widget;
        page.layoutCall.arguments.push(argument);
        return {
            page: page,
            valueType: valueType
        };
    }

	it('should create a custom widget property with enum properties', done => {
		client.openWorkingCopy("1", model => {
            const { page, valueType } = createSmallPage(model.allModules()[0]);

            valueType.attributeTypes.push(
                customwidgets.CustomWidgetAttributeType.Boolean,
                customwidgets.CustomWidgetAttributeType.String
            );

            model.closeConnection(() => {
                // Verify the deltas created during the process
				const deltas = (<StubClient> model['_client']).deltas.slice();
				assert.deepEqual(deltas.slice(-2), [ 
                    {
                        "unitId": page.id,
                        "elementId": valueType.id,
                        "deltaType": "UPDATE_PROPERTY_VALUE",
                        "propertyName": "attributeTypes",
                        "mutator": {
                            "insertionIndex": 0,
                            "value": "Boolean",
                            "mutatorType": "ADD"
                        }
                    },
                    {
                        "unitId": page.id,
                        "elementId": valueType.id,
                        "deltaType": "UPDATE_PROPERTY_VALUE",
                        "propertyName": "attributeTypes",
                        "mutator": {
                            "insertionIndex": 1,
                            "value": "String",
                            "mutatorType": "ADD"
                        }
                    }
                ]);
                done();
            });
		}, done);
	});

    it('should not be possible to add a null value to a partlist', done => {
        const client = createSdkClient();
        client.openWorkingCopy("1", model => {
            const module = projects.Module.createIn(model.root);
            const domainModel = domainmodels.DomainModel.createIn(module);

            assert.throw(() => {
                domainModel.entities.push(null);
            }, "Null values cannot be added to property");
            done();
        }, done);
    });

    it('should not be possible to add the same object to a partlist twice', done => {
        const client = createSdkClient();
        client.openWorkingCopy("1", model => {
            const module = projects.Module.createIn(model.root);
            const domainModel = domainmodels.DomainModel.createIn(module);
            const entities = domainmodels.Entity.createIn(domainModel);

            assert.throw(() => {
                domainModel.entities.push(entities);
            }, "was added more than once");
            done();
        }, done);
    });

	it("should not allow unsetting non-nillable properties", done => {
		client.openWorkingCopy("1", model => {
			const domainModel = createSmallDomainModel(model.root);

			assert.throw(() => {
				const attribute = domainModel.entities[0].attributes[0];
				attribute.type = null;
			}, "Cannot unset required part property");
			assert.throw(() => {
				const association = domainModel.associations[0];
				association.parent = null;
			}, "Cannot unset property");
			assert.throw(() => {
				const crossAssociation = domainModel.crossAssociations[0];
				crossAssociation.child = null;
			}, "Cannot unset required property");
			assert.throw(() => {
				const association = domainModel.associations[0];
				association.deleteBehavior.parentDeleteBehavior = null;
			}, "Cannot set parentDeleteBehavior to null");
			assert.throw(() => {
				const association = domainModel.associations[0];
				association.name = null;
			}, "Cannot set name to null");

			model.closeConnection(done, done);

		}, done);
	});

	it("should not allow pushing null to a listy by-name reference", done => {
		client.openWorkingCopy("1", model => {
			const domainModel = createSmallDomainModel(model.root);

            const accessRule = domainmodels.AccessRule.create(model);
            domainModel.entities[0].accessRules.push(accessRule);

			assert.throw(() => {
				accessRule.moduleRoles.push(null);
			}, "Cannot push null to moduleRoles");

			model.closeConnection(done, done);

		}, done);
	});

	it('should not allow pushing null to a listy enumeration property', done => {
		client.openWorkingCopy("1", model => {
            const { page, valueType } = createSmallPage(model.allModules()[0]);

            assert.throw(() => {
                valueType.attributeTypes.push(null);
            }, "Cannot push null to attributeTypes");

            model.closeConnection(done, done);
		}, done);
	});
    /*
     * This tests non-nillability of PrimitiveListProperty implicitly as EnumListProperty extends that.
     */

});
